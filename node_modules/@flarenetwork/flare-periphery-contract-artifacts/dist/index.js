'use strict';

var AgentInfo = require('./coston/artifacts/contracts/data/AgentInfo.sol/AgentInfo.json');
var AgentSettings = require('./coston/artifacts/contracts/data/AgentSettings.sol/AgentSettings.json');
var AssetManagerSettings = require('./coston/artifacts/contracts/data/AssetManagerSettings.sol/AssetManagerSettings.json');
var AvailableAgentInfo = require('./coston/artifacts/contracts/data/AvailableAgentInfo.sol/AvailableAgentInfo.json');
var CollateralReservationInfo = require('./coston/artifacts/contracts/data/CollateralReservationInfo.sol/CollateralReservationInfo.json');
var CollateralType = require('./coston/artifacts/contracts/data/CollateralType.sol/CollateralType.json');
var ContractRegistry = require('./coston/artifacts/contracts/ContractRegistry.sol/ContractRegistry.json');
var FtsoV2Interface = require('./coston/artifacts/contracts/FtsoV2Interface.sol/FtsoV2Interface.json');
var IAddressValidity = require('./coston/artifacts/contracts/IAddressValidity.sol/IAddressValidity.json');
var IAddressValidityVerification = require('./coston/artifacts/contracts/IAddressValidityVerification.sol/IAddressValidityVerification.json');
var IAgentAlwaysAllowedMinters = require('./coston/artifacts/contracts/IAgentAlwaysAllowedMinters.sol/IAgentAlwaysAllowedMinters.json');
var IAgentOwnerRegistry = require('./coston/artifacts/contracts/IAgentOwnerRegistry.sol/IAgentOwnerRegistry.json');
var IAgentPing = require('./coston/artifacts/contracts/IAgentPing.sol/IAgentPing.json');
var IAssetManager = require('./coston/artifacts/contracts/IAssetManager.sol/IAssetManager.json');
var IAssetManagerController = require('./coston/artifacts/contracts/IAssetManagerController.sol/IAssetManagerController.json');
var IAssetManagerEvents = require('./coston/artifacts/contracts/IAssetManagerEvents.sol/IAssetManagerEvents.json');
var IBalanceDecreasingTransaction = require('./coston/artifacts/contracts/IBalanceDecreasingTransaction.sol/IBalanceDecreasingTransaction.json');
var IBalanceDecreasingTransactionVerification = require('./coston/artifacts/contracts/IBalanceDecreasingTransactionVerification.sol/IBalanceDecreasingTransactionVerification.json');
var ICChainStake = require('./coston/artifacts/contracts/ICChainStake.sol/ICChainStake.json');
var ICChainVotePower = require('./coston/artifacts/contracts/ICChainVotePower.sol/ICChainVotePower.json');
var IClaimSetupManager = require('./coston/artifacts/contracts/IClaimSetupManager.sol/IClaimSetupManager.json');
var IConfirmedBlockHeightExists = require('./coston/artifacts/contracts/IConfirmedBlockHeightExists.sol/IConfirmedBlockHeightExists.json');
var IConfirmedBlockHeightExistsVerification = require('./coston/artifacts/contracts/IConfirmedBlockHeightExistsVerification.sol/IConfirmedBlockHeightExistsVerification.json');
var ICoreVaultClient = require('./coston/artifacts/contracts/ICoreVaultClient.sol/ICoreVaultClient.json');
var ICoreVaultClientSettings = require('./coston/artifacts/contracts/ICoreVaultClientSettings.sol/ICoreVaultClientSettings.json');
var IDelegationAccount = require('./coston/artifacts/contracts/IDelegationAccount.sol/IDelegationAccount.json');
var IDiamondLoupe = require('./coston/artifacts/contracts/diamond/interfaces/IDiamondLoupe.sol/IDiamondLoupe.json');
var IEVMTransaction = require('./coston/artifacts/contracts/IEVMTransaction.sol/IEVMTransaction.json');
var IEVMTransactionVerification = require('./coston/artifacts/contracts/IEVMTransactionVerification.sol/IEVMTransactionVerification.json');
var IEntityManager = require('./coston/artifacts/contracts/IEntityManager.sol/IEntityManager.json');
var IFastUpdateIncentiveManager = require('./coston/artifacts/contracts/IFastUpdateIncentiveManager.sol/IFastUpdateIncentiveManager.json');
var IFastUpdater = require('./coston/artifacts/contracts/IFastUpdater.sol/IFastUpdater.json');
var IFastUpdatesConfiguration = require('./coston/artifacts/contracts/IFastUpdatesConfiguration.sol/IFastUpdatesConfiguration.json');
var IFdcHub = require('./coston/artifacts/contracts/IFdcHub.sol/IFdcHub.json');
var IFdcInflationConfigurations = require('./coston/artifacts/contracts/IFdcInflationConfigurations.sol/IFdcInflationConfigurations.json');
var IFdcRequestFeeConfigurations = require('./coston/artifacts/contracts/IFdcRequestFeeConfigurations.sol/IFdcRequestFeeConfigurations.json');
var IFdcVerification = require('./coston/artifacts/contracts/IFdcVerification.sol/IFdcVerification.json');
var IFeeCalculator = require('./coston/artifacts/contracts/IFeeCalculator.sol/IFeeCalculator.json');
var IFlareAssetRegistry = require('./coston/artifacts/contracts/IFlareAssetRegistry.sol/IFlareAssetRegistry.json');
var IFlareContractRegistry = require('./coston/artifacts/contracts/IFlareContractRegistry.sol/IFlareContractRegistry.json');
var IFlareDaemonize = require('./coston/artifacts/contracts/genesis/interfaces/IFlareDaemonize.sol/IFlareDaemonize.json');
var IFlareSystemsCalculator = require('./coston/artifacts/contracts/IFlareSystemsCalculator.sol/IFlareSystemsCalculator.json');
var IFlareSystemsManager = require('./coston/artifacts/contracts/IFlareSystemsManager.sol/IFlareSystemsManager.json');
var IFtso = require('./coston/artifacts/contracts/IFtso.sol/IFtso.json');
var IFtsoFeedDecimals = require('./coston/artifacts/contracts/IFtsoFeedDecimals.sol/IFtsoFeedDecimals.json');
var IFtsoFeedIdConverter = require('./coston/artifacts/contracts/IFtsoFeedIdConverter.sol/IFtsoFeedIdConverter.json');
var IFtsoFeedPublisher = require('./coston/artifacts/contracts/IFtsoFeedPublisher.sol/IFtsoFeedPublisher.json');
var IFtsoGenesis = require('./coston/artifacts/contracts/genesis/interfaces/IFtsoGenesis.sol/IFtsoGenesis.json');
var IFtsoInflationConfigurations = require('./coston/artifacts/contracts/IFtsoInflationConfigurations.sol/IFtsoInflationConfigurations.json');
var IFtsoManager = require('./coston/artifacts/contracts/IFtsoManager.sol/IFtsoManager.json');
var IFtsoManagerGenesis = require('./coston/artifacts/contracts/genesis/interfaces/IFtsoManagerGenesis.sol/IFtsoManagerGenesis.json');
var IFtsoRegistry = require('./coston/artifacts/contracts/IFtsoRegistry.sol/IFtsoRegistry.json');
var IFtsoRegistryGenesis = require('./coston/artifacts/contracts/genesis/interfaces/IFtsoRegistryGenesis.sol/IFtsoRegistryGenesis.json');
var IFtsoRewardManager = require('./coston/artifacts/contracts/IFtsoRewardManager.sol/IFtsoRewardManager.json');
var IFtsoRewardOffersManager = require('./coston/artifacts/contracts/IFtsoRewardOffersManager.sol/IFtsoRewardOffersManager.json');
var IGenericRewardManager = require('./coston/artifacts/contracts/IGenericRewardManager.sol/IGenericRewardManager.json');
var IGovernanceSettings = require('./coston/artifacts/contracts/IGovernanceSettings.sol/IGovernanceSettings.json');
var IGovernanceVotePower = require('./coston/artifacts/contracts/IGovernanceVotePower.sol/IGovernanceVotePower.json');
var IGovernor = require('./coston/artifacts/contracts/IGovernor.sol/IGovernor.json');
var IIAddressUpdatable = require('./coston/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdatable.sol/IIAddressUpdatable.json');
var IIAddressUpdater = require('./coston/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdater.sol/IIAddressUpdater.json');
var IIClaimSetupManager = require('./coston/artifacts/contracts/protocol/interfaces/IIClaimSetupManager.sol/IIClaimSetupManager.json');
var IICleanable = require('./coston/artifacts/contracts/token/interfaces/IICleanable.sol/IICleanable.json');
var IICleanupBlockNumberManager = require('./coston/artifacts/contracts/protocol/interfaces/IICleanupBlockNumberManager.sol/IICleanupBlockNumberManager.json');
var IICustomFeed = require('./coston/artifacts/contracts/customFeeds/interfaces/IICustomFeed.sol/IICustomFeed.json');
var IIEntityManager = require('./coston/artifacts/contracts/protocol/interfaces/IIEntityManager.sol/IIEntityManager.json');
var IIFastUpdaterView = require('./coston/artifacts/contracts/fscV1/interfaces/IIFastUpdaterView.sol/IIFastUpdaterView.json');
var IIFlareSystemsCalculator = require('./coston/artifacts/contracts/protocol/interfaces/IIFlareSystemsCalculator.sol/IIFlareSystemsCalculator.json');
var IIFlareSystemsManager = require('./coston/artifacts/contracts/protocol/interfaces/IIFlareSystemsManager.sol/IIFlareSystemsManager.json');
var IIFtso = require('./coston/artifacts/contracts/ftso/interfaces/IIFtso.sol/IIFtso.json');
var IIFtsoFeedPublisher = require('./coston/artifacts/contracts/ftso/interfaces/IIFtsoFeedPublisher.sol/IIFtsoFeedPublisher.json');
var IIFtsoManagerProxy = require('./coston/artifacts/contracts/fscV1/interfaces/IIFtsoManagerProxy.sol/IIFtsoManagerProxy.json');
var IIGovernanceVotePower = require('./coston/artifacts/contracts/token/interfaces/IIGovernanceVotePower.sol/IIGovernanceVotePower.json');
var IIGovernorProposer = require('./coston/artifacts/contracts/governance/interfaces/IIGovernorProposer.sol/IIGovernorProposer.json');
var IINodePossessionVerifier = require('./coston/artifacts/contracts/protocol/interfaces/IINodePossessionVerifier.sol/IINodePossessionVerifier.json');
var IIPollingFoundation = require('./coston/artifacts/contracts/governance/interfaces/IIPollingFoundation.sol/IIPollingFoundation.json');
var IIPollingManagementGroup = require('./coston/artifacts/contracts/governance/interfaces/IIPollingManagementGroup.sol/IIPollingManagementGroup.json');
var IIPublicKeyVerifier = require('./coston/artifacts/contracts/protocol/interfaces/IIPublicKeyVerifier.sol/IIPublicKeyVerifier.json');
var IIRNat = require('./coston/artifacts/contracts/rNat/interfaces/IIRNat.sol/IIRNat.json');
var IIRNatAccount = require('./coston/artifacts/contracts/rNat/interfaces/IIRNatAccount.sol/IIRNatAccount.json');
var IIRelay = require('./coston/artifacts/contracts/protocol/interfaces/IIRelay.sol/IIRelay.json');
var IIRewardEpochSwitchoverTrigger = require('./coston/artifacts/contracts/protocol/interfaces/IIRewardEpochSwitchoverTrigger.sol/IIRewardEpochSwitchoverTrigger.json');
var IIRewardManager = require('./coston/artifacts/contracts/protocol/interfaces/IIRewardManager.sol/IIRewardManager.json');
var IISubmission = require('./coston/artifacts/contracts/protocol/interfaces/IISubmission.sol/IISubmission.json');
var IIVPContract = require('./coston/artifacts/contracts/token/interfaces/IIVPContract.sol/IIVPContract.json');
var IIVPToken = require('./coston/artifacts/contracts/token/interfaces/IIVPToken.sol/IIVPToken.json');
var IIVoterRegistrationTrigger = require('./coston/artifacts/contracts/protocol/interfaces/IIVoterRegistrationTrigger.sol/IIVoterRegistrationTrigger.json');
var IIVoterRegistry = require('./coston/artifacts/contracts/protocol/interfaces/IIVoterRegistry.sol/IIVoterRegistry.json');
var IIncreaseManager = require('./coston/artifacts/contracts/IIncreaseManager.sol/IIncreaseManager.json');
var IJsonApi = require('./coston/artifacts/contracts/IJsonApi.sol/IJsonApi.json');
var IJsonApiVerification = require('./coston/artifacts/contracts/IJsonApiVerification.sol/IJsonApiVerification.json');
var IPayment = require('./coston/artifacts/contracts/IPayment.sol/IPayment.json');
var IPaymentVerification = require('./coston/artifacts/contracts/IPaymentVerification.sol/IPaymentVerification.json');
var IPollingManagementGroup = require('./coston/artifacts/contracts/IPollingManagementGroup.sol/IPollingManagementGroup.json');
var IPriceSubmitter = require('./coston/artifacts/contracts/IPriceSubmitter.sol/IPriceSubmitter.json');
var IRNat = require('./coston/artifacts/contracts/IRNat.sol/IRNat.json');
var IRNatAccount = require('./coston/artifacts/contracts/IRNatAccount.sol/IRNatAccount.json');
var IRandomProvider = require('./coston/artifacts/contracts/IRandomProvider.sol/IRandomProvider.json');
var IRedemptionTimeExtension = require('./coston/artifacts/contracts/IRedemptionTimeExtension.sol/IRedemptionTimeExtension.json');
var IReferencedPaymentNonexistence = require('./coston/artifacts/contracts/IReferencedPaymentNonexistence.sol/IReferencedPaymentNonexistence.json');
var IReferencedPaymentNonexistenceVerification = require('./coston/artifacts/contracts/IReferencedPaymentNonexistenceVerification.sol/IReferencedPaymentNonexistenceVerification.json');
var IRelay = require('./coston/artifacts/contracts/IRelay.sol/IRelay.json');
var IRewardManager = require('./coston/artifacts/contracts/IRewardManager.sol/IRewardManager.json');
var ISubmission = require('./coston/artifacts/contracts/ISubmission.sol/ISubmission.json');
var ITypeTemplate = require('./coston/artifacts/contracts/fdc/interfaces/ITypeTemplate.sol/ITypeTemplate.json');
var ITypeTemplateVerification = require('./coston/artifacts/contracts/fdc/interfaces/ITypeTemplateVerification.sol/ITypeTemplateVerification.json');
var IVPContractEvents = require('./coston/artifacts/contracts/IVPContractEvents.sol/IVPContractEvents.json');
var IVPToken = require('./coston/artifacts/contracts/IVPToken.sol/IVPToken.json');
var IValidatorRewardOffersManager = require('./coston/artifacts/contracts/IValidatorRewardOffersManager.sol/IValidatorRewardOffersManager.json');
var IVoterPreRegistry = require('./coston/artifacts/contracts/IVoterPreRegistry.sol/IVoterPreRegistry.json');
var IVoterRegistry = require('./coston/artifacts/contracts/IVoterRegistry.sol/IVoterRegistry.json');
var IVoterWhitelister = require('./coston/artifacts/contracts/IVoterWhitelister.sol/IVoterWhitelister.json');
var IWNat = require('./coston/artifacts/contracts/IWNat.sol/IWNat.json');
var IWNatDelegationFee = require('./coston/artifacts/contracts/IWNatDelegationFee.sol/IWNatDelegationFee.json');
var IWeb2Json = require('./coston/artifacts/contracts/IWeb2Json.sol/IWeb2Json.json');
var IWeb2JsonVerification = require('./coston/artifacts/contracts/IWeb2JsonVerification.sol/IWeb2JsonVerification.json');
var ProtocolsV2Interface = require('./coston/artifacts/contracts/ProtocolsV2Interface.sol/ProtocolsV2Interface.json');
var RandomNumberV2Interface = require('./coston/artifacts/contracts/RandomNumberV2Interface.sol/RandomNumberV2Interface.json');
var RedemptionRequestInfo = require('./coston/artifacts/contracts/data/RedemptionRequestInfo.sol/RedemptionRequestInfo.json');
var RedemptionTicketInfo = require('./coston/artifacts/contracts/data/RedemptionTicketInfo.sol/RedemptionTicketInfo.json');
var RewardsV2Interface = require('./coston/artifacts/contracts/RewardsV2Interface.sol/RewardsV2Interface.json');
var TestFtsoV2Interface = require('./coston/artifacts/contracts/TestFtsoV2Interface.sol/TestFtsoV2Interface.json');
var AgentInfo$1 = require('./coston2/artifacts/contracts/data/AgentInfo.sol/AgentInfo.json');
var AgentSettings$1 = require('./coston2/artifacts/contracts/data/AgentSettings.sol/AgentSettings.json');
var AssetManagerSettings$1 = require('./coston2/artifacts/contracts/data/AssetManagerSettings.sol/AssetManagerSettings.json');
var AvailableAgentInfo$1 = require('./coston2/artifacts/contracts/data/AvailableAgentInfo.sol/AvailableAgentInfo.json');
var CollateralReservationInfo$1 = require('./coston2/artifacts/contracts/data/CollateralReservationInfo.sol/CollateralReservationInfo.json');
var CollateralType$1 = require('./coston2/artifacts/contracts/data/CollateralType.sol/CollateralType.json');
var ContractRegistry$1 = require('./coston2/artifacts/contracts/ContractRegistry.sol/ContractRegistry.json');
var FtsoV2Interface$1 = require('./coston2/artifacts/contracts/FtsoV2Interface.sol/FtsoV2Interface.json');
var IAddressBinder = require('./coston2/artifacts/contracts/IAddressBinder.sol/IAddressBinder.json');
var IAddressValidity$1 = require('./coston2/artifacts/contracts/IAddressValidity.sol/IAddressValidity.json');
var IAddressValidityVerification$1 = require('./coston2/artifacts/contracts/IAddressValidityVerification.sol/IAddressValidityVerification.json');
var IAgentAlwaysAllowedMinters$1 = require('./coston2/artifacts/contracts/IAgentAlwaysAllowedMinters.sol/IAgentAlwaysAllowedMinters.json');
var IAgentOwnerRegistry$1 = require('./coston2/artifacts/contracts/IAgentOwnerRegistry.sol/IAgentOwnerRegistry.json');
var IAgentPing$1 = require('./coston2/artifacts/contracts/IAgentPing.sol/IAgentPing.json');
var IAssetManager$1 = require('./coston2/artifacts/contracts/IAssetManager.sol/IAssetManager.json');
var IAssetManagerController$1 = require('./coston2/artifacts/contracts/IAssetManagerController.sol/IAssetManagerController.json');
var IAssetManagerEvents$1 = require('./coston2/artifacts/contracts/IAssetManagerEvents.sol/IAssetManagerEvents.json');
var IBalanceDecreasingTransaction$1 = require('./coston2/artifacts/contracts/IBalanceDecreasingTransaction.sol/IBalanceDecreasingTransaction.json');
var IBalanceDecreasingTransactionVerification$1 = require('./coston2/artifacts/contracts/IBalanceDecreasingTransactionVerification.sol/IBalanceDecreasingTransactionVerification.json');
var ICChainStake$1 = require('./coston2/artifacts/contracts/ICChainStake.sol/ICChainStake.json');
var ICChainVotePower$1 = require('./coston2/artifacts/contracts/ICChainVotePower.sol/ICChainVotePower.json');
var IClaimSetupManager$1 = require('./coston2/artifacts/contracts/IClaimSetupManager.sol/IClaimSetupManager.json');
var IConfirmedBlockHeightExists$1 = require('./coston2/artifacts/contracts/IConfirmedBlockHeightExists.sol/IConfirmedBlockHeightExists.json');
var IConfirmedBlockHeightExistsVerification$1 = require('./coston2/artifacts/contracts/IConfirmedBlockHeightExistsVerification.sol/IConfirmedBlockHeightExistsVerification.json');
var ICoreVaultClient$1 = require('./coston2/artifacts/contracts/ICoreVaultClient.sol/ICoreVaultClient.json');
var ICoreVaultClientSettings$1 = require('./coston2/artifacts/contracts/ICoreVaultClientSettings.sol/ICoreVaultClientSettings.json');
var IDelegationAccount$1 = require('./coston2/artifacts/contracts/IDelegationAccount.sol/IDelegationAccount.json');
var IDiamondLoupe$1 = require('./coston2/artifacts/contracts/diamond/interfaces/IDiamondLoupe.sol/IDiamondLoupe.json');
var IDistributionToDelegators = require('./coston2/artifacts/contracts/IDistributionToDelegators.sol/IDistributionToDelegators.json');
var IEVMTransaction$1 = require('./coston2/artifacts/contracts/IEVMTransaction.sol/IEVMTransaction.json');
var IEVMTransactionVerification$1 = require('./coston2/artifacts/contracts/IEVMTransactionVerification.sol/IEVMTransactionVerification.json');
var IEntityManager$1 = require('./coston2/artifacts/contracts/IEntityManager.sol/IEntityManager.json');
var IFastUpdateIncentiveManager$1 = require('./coston2/artifacts/contracts/IFastUpdateIncentiveManager.sol/IFastUpdateIncentiveManager.json');
var IFastUpdater$1 = require('./coston2/artifacts/contracts/IFastUpdater.sol/IFastUpdater.json');
var IFastUpdatesConfiguration$1 = require('./coston2/artifacts/contracts/IFastUpdatesConfiguration.sol/IFastUpdatesConfiguration.json');
var IFdcHub$1 = require('./coston2/artifacts/contracts/IFdcHub.sol/IFdcHub.json');
var IFdcInflationConfigurations$1 = require('./coston2/artifacts/contracts/IFdcInflationConfigurations.sol/IFdcInflationConfigurations.json');
var IFdcRequestFeeConfigurations$1 = require('./coston2/artifacts/contracts/IFdcRequestFeeConfigurations.sol/IFdcRequestFeeConfigurations.json');
var IFdcVerification$1 = require('./coston2/artifacts/contracts/IFdcVerification.sol/IFdcVerification.json');
var IFeeCalculator$1 = require('./coston2/artifacts/contracts/IFeeCalculator.sol/IFeeCalculator.json');
var IFlareAssetRegistry$1 = require('./coston2/artifacts/contracts/IFlareAssetRegistry.sol/IFlareAssetRegistry.json');
var IFlareContractRegistry$1 = require('./coston2/artifacts/contracts/IFlareContractRegistry.sol/IFlareContractRegistry.json');
var IFlareDaemonize$1 = require('./coston2/artifacts/contracts/genesis/interfaces/IFlareDaemonize.sol/IFlareDaemonize.json');
var IFlareSystemsCalculator$1 = require('./coston2/artifacts/contracts/IFlareSystemsCalculator.sol/IFlareSystemsCalculator.json');
var IFlareSystemsManager$1 = require('./coston2/artifacts/contracts/IFlareSystemsManager.sol/IFlareSystemsManager.json');
var IFtso$1 = require('./coston2/artifacts/contracts/IFtso.sol/IFtso.json');
var IFtsoFeedDecimals$1 = require('./coston2/artifacts/contracts/IFtsoFeedDecimals.sol/IFtsoFeedDecimals.json');
var IFtsoFeedIdConverter$1 = require('./coston2/artifacts/contracts/IFtsoFeedIdConverter.sol/IFtsoFeedIdConverter.json');
var IFtsoFeedPublisher$1 = require('./coston2/artifacts/contracts/IFtsoFeedPublisher.sol/IFtsoFeedPublisher.json');
var IFtsoGenesis$1 = require('./coston2/artifacts/contracts/genesis/interfaces/IFtsoGenesis.sol/IFtsoGenesis.json');
var IFtsoInflationConfigurations$1 = require('./coston2/artifacts/contracts/IFtsoInflationConfigurations.sol/IFtsoInflationConfigurations.json');
var IFtsoManager$1 = require('./coston2/artifacts/contracts/IFtsoManager.sol/IFtsoManager.json');
var IFtsoManagerGenesis$1 = require('./coston2/artifacts/contracts/genesis/interfaces/IFtsoManagerGenesis.sol/IFtsoManagerGenesis.json');
var IFtsoRegistry$1 = require('./coston2/artifacts/contracts/IFtsoRegistry.sol/IFtsoRegistry.json');
var IFtsoRegistryGenesis$1 = require('./coston2/artifacts/contracts/genesis/interfaces/IFtsoRegistryGenesis.sol/IFtsoRegistryGenesis.json');
var IFtsoRewardManager$1 = require('./coston2/artifacts/contracts/IFtsoRewardManager.sol/IFtsoRewardManager.json');
var IFtsoRewardOffersManager$1 = require('./coston2/artifacts/contracts/IFtsoRewardOffersManager.sol/IFtsoRewardOffersManager.json');
var IGenericRewardManager$1 = require('./coston2/artifacts/contracts/IGenericRewardManager.sol/IGenericRewardManager.json');
var IGovernanceSettings$1 = require('./coston2/artifacts/contracts/IGovernanceSettings.sol/IGovernanceSettings.json');
var IGovernanceVotePower$1 = require('./coston2/artifacts/contracts/IGovernanceVotePower.sol/IGovernanceVotePower.json');
var IGovernor$1 = require('./coston2/artifacts/contracts/IGovernor.sol/IGovernor.json');
var IIAddressUpdatable$1 = require('./coston2/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdatable.sol/IIAddressUpdatable.json');
var IIAddressUpdater$1 = require('./coston2/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdater.sol/IIAddressUpdater.json');
var IIClaimSetupManager$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIClaimSetupManager.sol/IIClaimSetupManager.json');
var IICleanable$1 = require('./coston2/artifacts/contracts/token/interfaces/IICleanable.sol/IICleanable.json');
var IICleanupBlockNumberManager$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IICleanupBlockNumberManager.sol/IICleanupBlockNumberManager.json');
var IICustomFeed$1 = require('./coston2/artifacts/contracts/customFeeds/interfaces/IICustomFeed.sol/IICustomFeed.json');
var IIEntityManager$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIEntityManager.sol/IIEntityManager.json');
var IIFastUpdaterView$1 = require('./coston2/artifacts/contracts/fscV1/interfaces/IIFastUpdaterView.sol/IIFastUpdaterView.json');
var IIFlareSystemsCalculator$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIFlareSystemsCalculator.sol/IIFlareSystemsCalculator.json');
var IIFlareSystemsManager$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIFlareSystemsManager.sol/IIFlareSystemsManager.json');
var IIFtso$1 = require('./coston2/artifacts/contracts/ftso/interfaces/IIFtso.sol/IIFtso.json');
var IIFtsoFeedPublisher$1 = require('./coston2/artifacts/contracts/ftso/interfaces/IIFtsoFeedPublisher.sol/IIFtsoFeedPublisher.json');
var IIFtsoManagerProxy$1 = require('./coston2/artifacts/contracts/fscV1/interfaces/IIFtsoManagerProxy.sol/IIFtsoManagerProxy.json');
var IIGovernanceVotePower$1 = require('./coston2/artifacts/contracts/token/interfaces/IIGovernanceVotePower.sol/IIGovernanceVotePower.json');
var IIGovernorProposer$1 = require('./coston2/artifacts/contracts/governance/interfaces/IIGovernorProposer.sol/IIGovernorProposer.json');
var IINodePossessionVerifier$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IINodePossessionVerifier.sol/IINodePossessionVerifier.json');
var IIPollingFoundation$1 = require('./coston2/artifacts/contracts/governance/interfaces/IIPollingFoundation.sol/IIPollingFoundation.json');
var IIPollingManagementGroup$1 = require('./coston2/artifacts/contracts/governance/interfaces/IIPollingManagementGroup.sol/IIPollingManagementGroup.json');
var IIPublicKeyVerifier$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIPublicKeyVerifier.sol/IIPublicKeyVerifier.json');
var IIRNat$1 = require('./coston2/artifacts/contracts/rNat/interfaces/IIRNat.sol/IIRNat.json');
var IIRNatAccount$1 = require('./coston2/artifacts/contracts/rNat/interfaces/IIRNatAccount.sol/IIRNatAccount.json');
var IIRelay$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIRelay.sol/IIRelay.json');
var IIRewardEpochSwitchoverTrigger$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIRewardEpochSwitchoverTrigger.sol/IIRewardEpochSwitchoverTrigger.json');
var IIRewardManager$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIRewardManager.sol/IIRewardManager.json');
var IISubmission$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IISubmission.sol/IISubmission.json');
var IIVPContract$1 = require('./coston2/artifacts/contracts/token/interfaces/IIVPContract.sol/IIVPContract.json');
var IIVPToken$1 = require('./coston2/artifacts/contracts/token/interfaces/IIVPToken.sol/IIVPToken.json');
var IIVoterRegistrationTrigger$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIVoterRegistrationTrigger.sol/IIVoterRegistrationTrigger.json');
var IIVoterRegistry$1 = require('./coston2/artifacts/contracts/protocol/interfaces/IIVoterRegistry.sol/IIVoterRegistry.json');
var IIncreaseManager$1 = require('./coston2/artifacts/contracts/IIncreaseManager.sol/IIncreaseManager.json');
var IJsonApi$1 = require('./coston2/artifacts/contracts/IJsonApi.sol/IJsonApi.json');
var IJsonApiVerification$1 = require('./coston2/artifacts/contracts/IJsonApiVerification.sol/IJsonApiVerification.json');
var IPChainStakeMirror = require('./coston2/artifacts/contracts/IPChainStakeMirror.sol/IPChainStakeMirror.json');
var IPChainStakeMirrorMultiSigVoting = require('./coston2/artifacts/contracts/IPChainStakeMirrorMultiSigVoting.sol/IPChainStakeMirrorMultiSigVoting.json');
var IPChainStakeMirrorVerifier = require('./coston2/artifacts/contracts/IPChainStakeMirrorVerifier.sol/IPChainStakeMirrorVerifier.json');
var IPChainVotePower = require('./coston2/artifacts/contracts/IPChainVotePower.sol/IPChainVotePower.json');
var IPayment$1 = require('./coston2/artifacts/contracts/IPayment.sol/IPayment.json');
var IPaymentVerification$1 = require('./coston2/artifacts/contracts/IPaymentVerification.sol/IPaymentVerification.json');
var IPollingFtso = require('./coston2/artifacts/contracts/IPollingFtso.sol/IPollingFtso.json');
var IPollingManagementGroup$1 = require('./coston2/artifacts/contracts/IPollingManagementGroup.sol/IPollingManagementGroup.json');
var IPriceSubmitter$1 = require('./coston2/artifacts/contracts/IPriceSubmitter.sol/IPriceSubmitter.json');
var IRNat$1 = require('./coston2/artifacts/contracts/IRNat.sol/IRNat.json');
var IRNatAccount$1 = require('./coston2/artifacts/contracts/IRNatAccount.sol/IRNatAccount.json');
var IRandomProvider$1 = require('./coston2/artifacts/contracts/IRandomProvider.sol/IRandomProvider.json');
var IRedemptionTimeExtension$1 = require('./coston2/artifacts/contracts/IRedemptionTimeExtension.sol/IRedemptionTimeExtension.json');
var IReferencedPaymentNonexistence$1 = require('./coston2/artifacts/contracts/IReferencedPaymentNonexistence.sol/IReferencedPaymentNonexistence.json');
var IReferencedPaymentNonexistenceVerification$1 = require('./coston2/artifacts/contracts/IReferencedPaymentNonexistenceVerification.sol/IReferencedPaymentNonexistenceVerification.json');
var IRelay$1 = require('./coston2/artifacts/contracts/IRelay.sol/IRelay.json');
var IRewardManager$1 = require('./coston2/artifacts/contracts/IRewardManager.sol/IRewardManager.json');
var ISubmission$1 = require('./coston2/artifacts/contracts/ISubmission.sol/ISubmission.json');
var ITypeTemplate$1 = require('./coston2/artifacts/contracts/fdc/interfaces/ITypeTemplate.sol/ITypeTemplate.json');
var ITypeTemplateVerification$1 = require('./coston2/artifacts/contracts/fdc/interfaces/ITypeTemplateVerification.sol/ITypeTemplateVerification.json');
var IVPContractEvents$1 = require('./coston2/artifacts/contracts/IVPContractEvents.sol/IVPContractEvents.json');
var IVPToken$1 = require('./coston2/artifacts/contracts/IVPToken.sol/IVPToken.json');
var IValidatorRegistry = require('./coston2/artifacts/contracts/IValidatorRegistry.sol/IValidatorRegistry.json');
var IValidatorRewardOffersManager$1 = require('./coston2/artifacts/contracts/IValidatorRewardOffersManager.sol/IValidatorRewardOffersManager.json');
var IVoterPreRegistry$1 = require('./coston2/artifacts/contracts/IVoterPreRegistry.sol/IVoterPreRegistry.json');
var IVoterRegistry$1 = require('./coston2/artifacts/contracts/IVoterRegistry.sol/IVoterRegistry.json');
var IVoterWhitelister$1 = require('./coston2/artifacts/contracts/IVoterWhitelister.sol/IVoterWhitelister.json');
var IWNat$1 = require('./coston2/artifacts/contracts/IWNat.sol/IWNat.json');
var IWNatDelegationFee$1 = require('./coston2/artifacts/contracts/IWNatDelegationFee.sol/IWNatDelegationFee.json');
var IWeb2Json$1 = require('./coston2/artifacts/contracts/IWeb2Json.sol/IWeb2Json.json');
var IWeb2JsonVerification$1 = require('./coston2/artifacts/contracts/IWeb2JsonVerification.sol/IWeb2JsonVerification.json');
var ProtocolsV2Interface$1 = require('./coston2/artifacts/contracts/ProtocolsV2Interface.sol/ProtocolsV2Interface.json');
var RandomNumberV2Interface$1 = require('./coston2/artifacts/contracts/RandomNumberV2Interface.sol/RandomNumberV2Interface.json');
var RedemptionRequestInfo$1 = require('./coston2/artifacts/contracts/data/RedemptionRequestInfo.sol/RedemptionRequestInfo.json');
var RedemptionTicketInfo$1 = require('./coston2/artifacts/contracts/data/RedemptionTicketInfo.sol/RedemptionTicketInfo.json');
var RewardsV2Interface$1 = require('./coston2/artifacts/contracts/RewardsV2Interface.sol/RewardsV2Interface.json');
var TestFtsoV2Interface$1 = require('./coston2/artifacts/contracts/TestFtsoV2Interface.sol/TestFtsoV2Interface.json');
var AgentInfo$2 = require('./flare/artifacts/contracts/data/AgentInfo.sol/AgentInfo.json');
var AgentSettings$2 = require('./flare/artifacts/contracts/data/AgentSettings.sol/AgentSettings.json');
var AssetManagerSettings$2 = require('./flare/artifacts/contracts/data/AssetManagerSettings.sol/AssetManagerSettings.json');
var AvailableAgentInfo$2 = require('./flare/artifacts/contracts/data/AvailableAgentInfo.sol/AvailableAgentInfo.json');
var CollateralReservationInfo$2 = require('./flare/artifacts/contracts/data/CollateralReservationInfo.sol/CollateralReservationInfo.json');
var CollateralType$2 = require('./flare/artifacts/contracts/data/CollateralType.sol/CollateralType.json');
var ContractRegistry$2 = require('./flare/artifacts/contracts/ContractRegistry.sol/ContractRegistry.json');
var FtsoV2Interface$2 = require('./flare/artifacts/contracts/FtsoV2Interface.sol/FtsoV2Interface.json');
var IAddressBinder$1 = require('./flare/artifacts/contracts/IAddressBinder.sol/IAddressBinder.json');
var IAddressValidity$2 = require('./flare/artifacts/contracts/IAddressValidity.sol/IAddressValidity.json');
var IAddressValidityVerification$2 = require('./flare/artifacts/contracts/IAddressValidityVerification.sol/IAddressValidityVerification.json');
var IAgentAlwaysAllowedMinters$2 = require('./flare/artifacts/contracts/IAgentAlwaysAllowedMinters.sol/IAgentAlwaysAllowedMinters.json');
var IAgentOwnerRegistry$2 = require('./flare/artifacts/contracts/IAgentOwnerRegistry.sol/IAgentOwnerRegistry.json');
var IAgentPing$2 = require('./flare/artifacts/contracts/IAgentPing.sol/IAgentPing.json');
var IAssetManager$2 = require('./flare/artifacts/contracts/IAssetManager.sol/IAssetManager.json');
var IAssetManagerController$2 = require('./flare/artifacts/contracts/IAssetManagerController.sol/IAssetManagerController.json');
var IAssetManagerEvents$2 = require('./flare/artifacts/contracts/IAssetManagerEvents.sol/IAssetManagerEvents.json');
var IBalanceDecreasingTransaction$2 = require('./flare/artifacts/contracts/IBalanceDecreasingTransaction.sol/IBalanceDecreasingTransaction.json');
var IBalanceDecreasingTransactionVerification$2 = require('./flare/artifacts/contracts/IBalanceDecreasingTransactionVerification.sol/IBalanceDecreasingTransactionVerification.json');
var ICChainStake$2 = require('./flare/artifacts/contracts/ICChainStake.sol/ICChainStake.json');
var ICChainVotePower$2 = require('./flare/artifacts/contracts/ICChainVotePower.sol/ICChainVotePower.json');
var IClaimSetupManager$2 = require('./flare/artifacts/contracts/IClaimSetupManager.sol/IClaimSetupManager.json');
var IConfirmedBlockHeightExists$2 = require('./flare/artifacts/contracts/IConfirmedBlockHeightExists.sol/IConfirmedBlockHeightExists.json');
var IConfirmedBlockHeightExistsVerification$2 = require('./flare/artifacts/contracts/IConfirmedBlockHeightExistsVerification.sol/IConfirmedBlockHeightExistsVerification.json');
var ICoreVault = require('./flare/artifacts/contracts/ICoreVault.sol/ICoreVault.json');
var ICoreVaultSettings = require('./flare/artifacts/contracts/ICoreVaultSettings.sol/ICoreVaultSettings.json');
var IDelegationAccount$2 = require('./flare/artifacts/contracts/IDelegationAccount.sol/IDelegationAccount.json');
var IDiamondLoupe$2 = require('./flare/artifacts/contracts/diamond/interfaces/IDiamondLoupe.sol/IDiamondLoupe.json');
var IDistributionToDelegators$1 = require('./flare/artifacts/contracts/IDistributionToDelegators.sol/IDistributionToDelegators.json');
var IEVMTransaction$2 = require('./flare/artifacts/contracts/IEVMTransaction.sol/IEVMTransaction.json');
var IEVMTransactionVerification$2 = require('./flare/artifacts/contracts/IEVMTransactionVerification.sol/IEVMTransactionVerification.json');
var IEntityManager$2 = require('./flare/artifacts/contracts/IEntityManager.sol/IEntityManager.json');
var IFastUpdateIncentiveManager$2 = require('./flare/artifacts/contracts/IFastUpdateIncentiveManager.sol/IFastUpdateIncentiveManager.json');
var IFastUpdater$2 = require('./flare/artifacts/contracts/IFastUpdater.sol/IFastUpdater.json');
var IFastUpdatesConfiguration$2 = require('./flare/artifacts/contracts/IFastUpdatesConfiguration.sol/IFastUpdatesConfiguration.json');
var IFdcHub$2 = require('./flare/artifacts/contracts/IFdcHub.sol/IFdcHub.json');
var IFdcInflationConfigurations$2 = require('./flare/artifacts/contracts/IFdcInflationConfigurations.sol/IFdcInflationConfigurations.json');
var IFdcRequestFeeConfigurations$2 = require('./flare/artifacts/contracts/IFdcRequestFeeConfigurations.sol/IFdcRequestFeeConfigurations.json');
var IFdcVerification$2 = require('./flare/artifacts/contracts/IFdcVerification.sol/IFdcVerification.json');
var IFeeCalculator$2 = require('./flare/artifacts/contracts/IFeeCalculator.sol/IFeeCalculator.json');
var IFlareAssetRegistry$2 = require('./flare/artifacts/contracts/IFlareAssetRegistry.sol/IFlareAssetRegistry.json');
var IFlareContractRegistry$2 = require('./flare/artifacts/contracts/IFlareContractRegistry.sol/IFlareContractRegistry.json');
var IFlareDaemonize$2 = require('./flare/artifacts/contracts/genesis/interfaces/IFlareDaemonize.sol/IFlareDaemonize.json');
var IFlareSystemsCalculator$2 = require('./flare/artifacts/contracts/IFlareSystemsCalculator.sol/IFlareSystemsCalculator.json');
var IFlareSystemsManager$2 = require('./flare/artifacts/contracts/IFlareSystemsManager.sol/IFlareSystemsManager.json');
var IFtso$2 = require('./flare/artifacts/contracts/IFtso.sol/IFtso.json');
var IFtsoFeedDecimals$2 = require('./flare/artifacts/contracts/IFtsoFeedDecimals.sol/IFtsoFeedDecimals.json');
var IFtsoFeedIdConverter$2 = require('./flare/artifacts/contracts/IFtsoFeedIdConverter.sol/IFtsoFeedIdConverter.json');
var IFtsoFeedPublisher$2 = require('./flare/artifacts/contracts/IFtsoFeedPublisher.sol/IFtsoFeedPublisher.json');
var IFtsoGenesis$2 = require('./flare/artifacts/contracts/genesis/interfaces/IFtsoGenesis.sol/IFtsoGenesis.json');
var IFtsoInflationConfigurations$2 = require('./flare/artifacts/contracts/IFtsoInflationConfigurations.sol/IFtsoInflationConfigurations.json');
var IFtsoManager$2 = require('./flare/artifacts/contracts/IFtsoManager.sol/IFtsoManager.json');
var IFtsoManagerGenesis$2 = require('./flare/artifacts/contracts/genesis/interfaces/IFtsoManagerGenesis.sol/IFtsoManagerGenesis.json');
var IFtsoRegistry$2 = require('./flare/artifacts/contracts/IFtsoRegistry.sol/IFtsoRegistry.json');
var IFtsoRegistryGenesis$2 = require('./flare/artifacts/contracts/genesis/interfaces/IFtsoRegistryGenesis.sol/IFtsoRegistryGenesis.json');
var IFtsoRewardManager$2 = require('./flare/artifacts/contracts/IFtsoRewardManager.sol/IFtsoRewardManager.json');
var IFtsoRewardOffersManager$2 = require('./flare/artifacts/contracts/IFtsoRewardOffersManager.sol/IFtsoRewardOffersManager.json');
var IGenericRewardManager$2 = require('./flare/artifacts/contracts/IGenericRewardManager.sol/IGenericRewardManager.json');
var IGovernanceSettings$2 = require('./flare/artifacts/contracts/IGovernanceSettings.sol/IGovernanceSettings.json');
var IGovernanceVotePower$2 = require('./flare/artifacts/contracts/IGovernanceVotePower.sol/IGovernanceVotePower.json');
var IGovernor$2 = require('./flare/artifacts/contracts/IGovernor.sol/IGovernor.json');
var IIAddressUpdatable$2 = require('./flare/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdatable.sol/IIAddressUpdatable.json');
var IIAddressUpdater$2 = require('./flare/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdater.sol/IIAddressUpdater.json');
var IIClaimSetupManager$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIClaimSetupManager.sol/IIClaimSetupManager.json');
var IICleanable$2 = require('./flare/artifacts/contracts/token/interfaces/IICleanable.sol/IICleanable.json');
var IICleanupBlockNumberManager$2 = require('./flare/artifacts/contracts/protocol/interfaces/IICleanupBlockNumberManager.sol/IICleanupBlockNumberManager.json');
var IICustomFeed$2 = require('./flare/artifacts/contracts/customFeeds/interfaces/IICustomFeed.sol/IICustomFeed.json');
var IIEntityManager$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIEntityManager.sol/IIEntityManager.json');
var IIFastUpdaterView$2 = require('./flare/artifacts/contracts/fscV1/interfaces/IIFastUpdaterView.sol/IIFastUpdaterView.json');
var IIFlareSystemsCalculator$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIFlareSystemsCalculator.sol/IIFlareSystemsCalculator.json');
var IIFlareSystemsManager$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIFlareSystemsManager.sol/IIFlareSystemsManager.json');
var IIFtso$2 = require('./flare/artifacts/contracts/ftso/interfaces/IIFtso.sol/IIFtso.json');
var IIFtsoFeedPublisher$2 = require('./flare/artifacts/contracts/ftso/interfaces/IIFtsoFeedPublisher.sol/IIFtsoFeedPublisher.json');
var IIFtsoManagerProxy$2 = require('./flare/artifacts/contracts/fscV1/interfaces/IIFtsoManagerProxy.sol/IIFtsoManagerProxy.json');
var IIGovernanceVotePower$2 = require('./flare/artifacts/contracts/token/interfaces/IIGovernanceVotePower.sol/IIGovernanceVotePower.json');
var IIGovernorProposer$2 = require('./flare/artifacts/contracts/governance/interfaces/IIGovernorProposer.sol/IIGovernorProposer.json');
var IINodePossessionVerifier$2 = require('./flare/artifacts/contracts/protocol/interfaces/IINodePossessionVerifier.sol/IINodePossessionVerifier.json');
var IIPollingFoundation$2 = require('./flare/artifacts/contracts/governance/interfaces/IIPollingFoundation.sol/IIPollingFoundation.json');
var IIPollingManagementGroup$2 = require('./flare/artifacts/contracts/governance/interfaces/IIPollingManagementGroup.sol/IIPollingManagementGroup.json');
var IIPublicKeyVerifier$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIPublicKeyVerifier.sol/IIPublicKeyVerifier.json');
var IIRNat$2 = require('./flare/artifacts/contracts/rNat/interfaces/IIRNat.sol/IIRNat.json');
var IIRNatAccount$2 = require('./flare/artifacts/contracts/rNat/interfaces/IIRNatAccount.sol/IIRNatAccount.json');
var IIRelay$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIRelay.sol/IIRelay.json');
var IIRewardEpochSwitchoverTrigger$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIRewardEpochSwitchoverTrigger.sol/IIRewardEpochSwitchoverTrigger.json');
var IIRewardManager$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIRewardManager.sol/IIRewardManager.json');
var IISubmission$2 = require('./flare/artifacts/contracts/protocol/interfaces/IISubmission.sol/IISubmission.json');
var IIVPContract$2 = require('./flare/artifacts/contracts/token/interfaces/IIVPContract.sol/IIVPContract.json');
var IIVPToken$2 = require('./flare/artifacts/contracts/token/interfaces/IIVPToken.sol/IIVPToken.json');
var IIVoterRegistrationTrigger$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIVoterRegistrationTrigger.sol/IIVoterRegistrationTrigger.json');
var IIVoterRegistry$2 = require('./flare/artifacts/contracts/protocol/interfaces/IIVoterRegistry.sol/IIVoterRegistry.json');
var IIncreaseManager$2 = require('./flare/artifacts/contracts/IIncreaseManager.sol/IIncreaseManager.json');
var IJsonApi$2 = require('./flare/artifacts/contracts/IJsonApi.sol/IJsonApi.json');
var IJsonApiVerification$2 = require('./flare/artifacts/contracts/IJsonApiVerification.sol/IJsonApiVerification.json');
var IPChainStakeMirror$1 = require('./flare/artifacts/contracts/IPChainStakeMirror.sol/IPChainStakeMirror.json');
var IPChainStakeMirrorMultiSigVoting$1 = require('./flare/artifacts/contracts/IPChainStakeMirrorMultiSigVoting.sol/IPChainStakeMirrorMultiSigVoting.json');
var IPChainStakeMirrorVerifier$1 = require('./flare/artifacts/contracts/IPChainStakeMirrorVerifier.sol/IPChainStakeMirrorVerifier.json');
var IPChainVotePower$1 = require('./flare/artifacts/contracts/IPChainVotePower.sol/IPChainVotePower.json');
var IPayment$2 = require('./flare/artifacts/contracts/IPayment.sol/IPayment.json');
var IPaymentVerification$2 = require('./flare/artifacts/contracts/IPaymentVerification.sol/IPaymentVerification.json');
var IPollingFtso$1 = require('./flare/artifacts/contracts/IPollingFtso.sol/IPollingFtso.json');
var IPollingManagementGroup$2 = require('./flare/artifacts/contracts/IPollingManagementGroup.sol/IPollingManagementGroup.json');
var IPriceSubmitter$2 = require('./flare/artifacts/contracts/IPriceSubmitter.sol/IPriceSubmitter.json');
var IRNat$2 = require('./flare/artifacts/contracts/IRNat.sol/IRNat.json');
var IRNatAccount$2 = require('./flare/artifacts/contracts/IRNatAccount.sol/IRNatAccount.json');
var IRandomProvider$2 = require('./flare/artifacts/contracts/IRandomProvider.sol/IRandomProvider.json');
var IRedemptionTimeExtension$2 = require('./flare/artifacts/contracts/IRedemptionTimeExtension.sol/IRedemptionTimeExtension.json');
var IReferencedPaymentNonexistence$2 = require('./flare/artifacts/contracts/IReferencedPaymentNonexistence.sol/IReferencedPaymentNonexistence.json');
var IReferencedPaymentNonexistenceVerification$2 = require('./flare/artifacts/contracts/IReferencedPaymentNonexistenceVerification.sol/IReferencedPaymentNonexistenceVerification.json');
var IRelay$2 = require('./flare/artifacts/contracts/IRelay.sol/IRelay.json');
var IRewardManager$2 = require('./flare/artifacts/contracts/IRewardManager.sol/IRewardManager.json');
var ISubmission$2 = require('./flare/artifacts/contracts/ISubmission.sol/ISubmission.json');
var ITransferFees = require('./flare/artifacts/contracts/ITransferFees.sol/ITransferFees.json');
var ITypeTemplate$2 = require('./flare/artifacts/contracts/fdc/interfaces/ITypeTemplate.sol/ITypeTemplate.json');
var ITypeTemplateVerification$2 = require('./flare/artifacts/contracts/fdc/interfaces/ITypeTemplateVerification.sol/ITypeTemplateVerification.json');
var IVPContractEvents$2 = require('./flare/artifacts/contracts/IVPContractEvents.sol/IVPContractEvents.json');
var IVPToken$2 = require('./flare/artifacts/contracts/IVPToken.sol/IVPToken.json');
var IValidatorRegistry$1 = require('./flare/artifacts/contracts/IValidatorRegistry.sol/IValidatorRegistry.json');
var IValidatorRewardOffersManager$2 = require('./flare/artifacts/contracts/IValidatorRewardOffersManager.sol/IValidatorRewardOffersManager.json');
var IVoterPreRegistry$2 = require('./flare/artifacts/contracts/IVoterPreRegistry.sol/IVoterPreRegistry.json');
var IVoterRegistry$2 = require('./flare/artifacts/contracts/IVoterRegistry.sol/IVoterRegistry.json');
var IVoterWhitelister$2 = require('./flare/artifacts/contracts/IVoterWhitelister.sol/IVoterWhitelister.json');
var IWNat$2 = require('./flare/artifacts/contracts/IWNat.sol/IWNat.json');
var IWNatDelegationFee$2 = require('./flare/artifacts/contracts/IWNatDelegationFee.sol/IWNatDelegationFee.json');
var IWeb2Json$2 = require('./flare/artifacts/contracts/IWeb2Json.sol/IWeb2Json.json');
var IWeb2JsonVerification$2 = require('./flare/artifacts/contracts/IWeb2JsonVerification.sol/IWeb2JsonVerification.json');
var IWhitelist = require('./flare/artifacts/contracts/IWhitelist.sol/IWhitelist.json');
var ProtocolsV2Interface$2 = require('./flare/artifacts/contracts/ProtocolsV2Interface.sol/ProtocolsV2Interface.json');
var RandomNumberV2Interface$2 = require('./flare/artifacts/contracts/RandomNumberV2Interface.sol/RandomNumberV2Interface.json');
var RedemptionRequestInfo$2 = require('./flare/artifacts/contracts/data/RedemptionRequestInfo.sol/RedemptionRequestInfo.json');
var RedemptionTicketInfo$2 = require('./flare/artifacts/contracts/data/RedemptionTicketInfo.sol/RedemptionTicketInfo.json');
var RewardsV2Interface$2 = require('./flare/artifacts/contracts/RewardsV2Interface.sol/RewardsV2Interface.json');
var TestFtsoV2Interface$2 = require('./flare/artifacts/contracts/TestFtsoV2Interface.sol/TestFtsoV2Interface.json');
var AgentInfo$3 = require('./songbird/artifacts/contracts/data/AgentInfo.sol/AgentInfo.json');
var AgentSettings$3 = require('./songbird/artifacts/contracts/data/AgentSettings.sol/AgentSettings.json');
var AssetManagerSettings$3 = require('./songbird/artifacts/contracts/data/AssetManagerSettings.sol/AssetManagerSettings.json');
var AvailableAgentInfo$3 = require('./songbird/artifacts/contracts/data/AvailableAgentInfo.sol/AvailableAgentInfo.json');
var CollateralReservationInfo$3 = require('./songbird/artifacts/contracts/data/CollateralReservationInfo.sol/CollateralReservationInfo.json');
var CollateralType$3 = require('./songbird/artifacts/contracts/data/CollateralType.sol/CollateralType.json');
var ContractRegistry$3 = require('./songbird/artifacts/contracts/ContractRegistry.sol/ContractRegistry.json');
var FtsoV2Interface$3 = require('./songbird/artifacts/contracts/FtsoV2Interface.sol/FtsoV2Interface.json');
var IAddressValidity$3 = require('./songbird/artifacts/contracts/IAddressValidity.sol/IAddressValidity.json');
var IAddressValidityVerification$3 = require('./songbird/artifacts/contracts/IAddressValidityVerification.sol/IAddressValidityVerification.json');
var IAgentAlwaysAllowedMinters$3 = require('./songbird/artifacts/contracts/IAgentAlwaysAllowedMinters.sol/IAgentAlwaysAllowedMinters.json');
var IAgentOwnerRegistry$3 = require('./songbird/artifacts/contracts/IAgentOwnerRegistry.sol/IAgentOwnerRegistry.json');
var IAgentPing$3 = require('./songbird/artifacts/contracts/IAgentPing.sol/IAgentPing.json');
var IAssetManager$3 = require('./songbird/artifacts/contracts/IAssetManager.sol/IAssetManager.json');
var IAssetManagerController$3 = require('./songbird/artifacts/contracts/IAssetManagerController.sol/IAssetManagerController.json');
var IAssetManagerEvents$3 = require('./songbird/artifacts/contracts/IAssetManagerEvents.sol/IAssetManagerEvents.json');
var IBalanceDecreasingTransaction$3 = require('./songbird/artifacts/contracts/IBalanceDecreasingTransaction.sol/IBalanceDecreasingTransaction.json');
var IBalanceDecreasingTransactionVerification$3 = require('./songbird/artifacts/contracts/IBalanceDecreasingTransactionVerification.sol/IBalanceDecreasingTransactionVerification.json');
var ICChainStake$3 = require('./songbird/artifacts/contracts/ICChainStake.sol/ICChainStake.json');
var ICChainVotePower$3 = require('./songbird/artifacts/contracts/ICChainVotePower.sol/ICChainVotePower.json');
var IClaimSetupManager$3 = require('./songbird/artifacts/contracts/IClaimSetupManager.sol/IClaimSetupManager.json');
var ICollateralizable = require('./songbird/artifacts/contracts/mockXAsset/interfaces/ICollateralizable.sol/ICollateralizable.json');
var IConfirmedBlockHeightExists$3 = require('./songbird/artifacts/contracts/IConfirmedBlockHeightExists.sol/IConfirmedBlockHeightExists.json');
var IConfirmedBlockHeightExistsVerification$3 = require('./songbird/artifacts/contracts/IConfirmedBlockHeightExistsVerification.sol/IConfirmedBlockHeightExistsVerification.json');
var ICoreVault$1 = require('./songbird/artifacts/contracts/ICoreVault.sol/ICoreVault.json');
var ICoreVaultSettings$1 = require('./songbird/artifacts/contracts/ICoreVaultSettings.sol/ICoreVaultSettings.json');
var IDelegationAccount$3 = require('./songbird/artifacts/contracts/IDelegationAccount.sol/IDelegationAccount.json');
var IDiamondLoupe$3 = require('./songbird/artifacts/contracts/diamond/interfaces/IDiamondLoupe.sol/IDiamondLoupe.json');
var IEVMTransaction$3 = require('./songbird/artifacts/contracts/IEVMTransaction.sol/IEVMTransaction.json');
var IEVMTransactionVerification$3 = require('./songbird/artifacts/contracts/IEVMTransactionVerification.sol/IEVMTransactionVerification.json');
var IEntityManager$3 = require('./songbird/artifacts/contracts/IEntityManager.sol/IEntityManager.json');
var IFastUpdateIncentiveManager$3 = require('./songbird/artifacts/contracts/IFastUpdateIncentiveManager.sol/IFastUpdateIncentiveManager.json');
var IFastUpdater$3 = require('./songbird/artifacts/contracts/IFastUpdater.sol/IFastUpdater.json');
var IFastUpdatesConfiguration$3 = require('./songbird/artifacts/contracts/IFastUpdatesConfiguration.sol/IFastUpdatesConfiguration.json');
var IFdcHub$3 = require('./songbird/artifacts/contracts/IFdcHub.sol/IFdcHub.json');
var IFdcInflationConfigurations$3 = require('./songbird/artifacts/contracts/IFdcInflationConfigurations.sol/IFdcInflationConfigurations.json');
var IFdcRequestFeeConfigurations$3 = require('./songbird/artifacts/contracts/IFdcRequestFeeConfigurations.sol/IFdcRequestFeeConfigurations.json');
var IFdcVerification$3 = require('./songbird/artifacts/contracts/IFdcVerification.sol/IFdcVerification.json');
var IFeeCalculator$3 = require('./songbird/artifacts/contracts/IFeeCalculator.sol/IFeeCalculator.json');
var IFlareAssetRegistry$3 = require('./songbird/artifacts/contracts/IFlareAssetRegistry.sol/IFlareAssetRegistry.json');
var IFlareContractRegistry$3 = require('./songbird/artifacts/contracts/IFlareContractRegistry.sol/IFlareContractRegistry.json');
var IFlareDaemonize$3 = require('./songbird/artifacts/contracts/genesis/interfaces/IFlareDaemonize.sol/IFlareDaemonize.json');
var IFlareSystemsCalculator$3 = require('./songbird/artifacts/contracts/IFlareSystemsCalculator.sol/IFlareSystemsCalculator.json');
var IFlareSystemsManager$3 = require('./songbird/artifacts/contracts/IFlareSystemsManager.sol/IFlareSystemsManager.json');
var IFtso$3 = require('./songbird/artifacts/contracts/IFtso.sol/IFtso.json');
var IFtsoFeedDecimals$3 = require('./songbird/artifacts/contracts/IFtsoFeedDecimals.sol/IFtsoFeedDecimals.json');
var IFtsoFeedIdConverter$3 = require('./songbird/artifacts/contracts/IFtsoFeedIdConverter.sol/IFtsoFeedIdConverter.json');
var IFtsoFeedPublisher$3 = require('./songbird/artifacts/contracts/IFtsoFeedPublisher.sol/IFtsoFeedPublisher.json');
var IFtsoGenesis$3 = require('./songbird/artifacts/contracts/genesis/interfaces/IFtsoGenesis.sol/IFtsoGenesis.json');
var IFtsoInflationConfigurations$3 = require('./songbird/artifacts/contracts/IFtsoInflationConfigurations.sol/IFtsoInflationConfigurations.json');
var IFtsoManager$3 = require('./songbird/artifacts/contracts/IFtsoManager.sol/IFtsoManager.json');
var IFtsoManagerGenesis$3 = require('./songbird/artifacts/contracts/genesis/interfaces/IFtsoManagerGenesis.sol/IFtsoManagerGenesis.json');
var IFtsoRegistry$3 = require('./songbird/artifacts/contracts/IFtsoRegistry.sol/IFtsoRegistry.json');
var IFtsoRegistryGenesis$3 = require('./songbird/artifacts/contracts/genesis/interfaces/IFtsoRegistryGenesis.sol/IFtsoRegistryGenesis.json');
var IFtsoRewardManager$3 = require('./songbird/artifacts/contracts/IFtsoRewardManager.sol/IFtsoRewardManager.json');
var IFtsoRewardOffersManager$3 = require('./songbird/artifacts/contracts/IFtsoRewardOffersManager.sol/IFtsoRewardOffersManager.json');
var IGenericRewardManager$3 = require('./songbird/artifacts/contracts/IGenericRewardManager.sol/IGenericRewardManager.json');
var IGovernanceSettings$3 = require('./songbird/artifacts/contracts/IGovernanceSettings.sol/IGovernanceSettings.json');
var IGovernanceVotePower$3 = require('./songbird/artifacts/contracts/IGovernanceVotePower.sol/IGovernanceVotePower.json');
var IGovernor$3 = require('./songbird/artifacts/contracts/IGovernor.sol/IGovernor.json');
var IIAddressUpdatable$3 = require('./songbird/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdatable.sol/IIAddressUpdatable.json');
var IIAddressUpdater$3 = require('./songbird/artifacts/contracts/addressUpdater/interfaces/IIAddressUpdater.sol/IIAddressUpdater.json');
var IIClaimSetupManager$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIClaimSetupManager.sol/IIClaimSetupManager.json');
var IICleanable$3 = require('./songbird/artifacts/contracts/token/interfaces/IICleanable.sol/IICleanable.json');
var IICleanupBlockNumberManager$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IICleanupBlockNumberManager.sol/IICleanupBlockNumberManager.json');
var IICustomFeed$3 = require('./songbird/artifacts/contracts/customFeeds/interfaces/IICustomFeed.sol/IICustomFeed.json');
var IIERC20WithMetadata = require('./songbird/artifacts/contracts/assetRegistry/interfaces/IIERC20WithMetadata.sol/IIERC20WithMetadata.json');
var IIEntityManager$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIEntityManager.sol/IIEntityManager.json');
var IIFastUpdaterView$3 = require('./songbird/artifacts/contracts/fscV1/interfaces/IIFastUpdaterView.sol/IIFastUpdaterView.json');
var IIFlareAssetRegistry = require('./songbird/artifacts/contracts/assetRegistry/interfaces/IIFlareAssetRegistry.sol/IIFlareAssetRegistry.json');
var IIFlareAssetRegistryProvider = require('./songbird/artifacts/contracts/assetRegistry/interfaces/IIFlareAssetRegistryProvider.sol/IIFlareAssetRegistryProvider.json');
var IIFlareSystemsCalculator$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIFlareSystemsCalculator.sol/IIFlareSystemsCalculator.json');
var IIFlareSystemsManager$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIFlareSystemsManager.sol/IIFlareSystemsManager.json');
var IIFtso$3 = require('./songbird/artifacts/contracts/ftso/interfaces/IIFtso.sol/IIFtso.json');
var IIFtsoFeedPublisher$3 = require('./songbird/artifacts/contracts/ftso/interfaces/IIFtsoFeedPublisher.sol/IIFtsoFeedPublisher.json');
var IIFtsoManager = require('./songbird/artifacts/contracts/ftso/interfaces/IIFtsoManager.sol/IIFtsoManager.json');
var IIFtsoManagerProxy$3 = require('./songbird/artifacts/contracts/fscV1/interfaces/IIFtsoManagerProxy.sol/IIFtsoManagerProxy.json');
var IIFtsoManagerV1 = require('./songbird/artifacts/contracts/ftso/interfaces/IIFtsoManagerV1.sol/IIFtsoManagerV1.json');
var IIFtsoRegistry = require('./songbird/artifacts/contracts/utils/interfaces/IIFtsoRegistry.sol/IIFtsoRegistry.json');
var IIFtsoRegistryV1 = require('./songbird/artifacts/contracts/utils/interfaces/IIFtsoRegistryV1.sol/IIFtsoRegistryV1.json');
var IIFtsoRewardManager = require('./songbird/artifacts/contracts/tokenPools/interfaces/IIFtsoRewardManager.sol/IIFtsoRewardManager.json');
var IIGovernanceVotePower$3 = require('./songbird/artifacts/contracts/token/interfaces/IIGovernanceVotePower.sol/IIGovernanceVotePower.json');
var IIGovernorProposer$3 = require('./songbird/artifacts/contracts/governance/interfaces/IIGovernorProposer.sol/IIGovernorProposer.json');
var IIInflationAllocation = require('./songbird/artifacts/contracts/inflation/interfaces/IIInflationAllocation.sol/IIInflationAllocation.json');
var IIInflationReceiver = require('./songbird/artifacts/contracts/inflation/interfaces/IIInflationReceiver.sol/IIInflationReceiver.json');
var IIInflationReceiverV1 = require('./songbird/artifacts/contracts/inflation/interfaces/IIInflationReceiverV1.sol/IIInflationReceiverV1.json');
var IIInflationV1 = require('./songbird/artifacts/contracts/inflation/interfaces/IIInflationV1.sol/IIInflationV1.json');
var IINodePossessionVerifier$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IINodePossessionVerifier.sol/IINodePossessionVerifier.json');
var IIPollingFoundation$3 = require('./songbird/artifacts/contracts/governance/interfaces/IIPollingFoundation.sol/IIPollingFoundation.json');
var IIPollingManagementGroup$3 = require('./songbird/artifacts/contracts/governance/interfaces/IIPollingManagementGroup.sol/IIPollingManagementGroup.json');
var IIPreInflationCalculation = require('./songbird/artifacts/contracts/inflation/interfaces/IIPreInflationCalculation.sol/IIPreInflationCalculation.json');
var IIPriceSubmitter = require('./songbird/artifacts/contracts/genesis/interfaces/IIPriceSubmitter.sol/IIPriceSubmitter.json');
var IIPublicKeyVerifier$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIPublicKeyVerifier.sol/IIPublicKeyVerifier.json');
var IIRNat$3 = require('./songbird/artifacts/contracts/rNat/interfaces/IIRNat.sol/IIRNat.json');
var IIRNatAccount$3 = require('./songbird/artifacts/contracts/rNat/interfaces/IIRNatAccount.sol/IIRNatAccount.json');
var IIRandomProvider = require('./songbird/artifacts/contracts/utils/interfaces/IIRandomProvider.sol/IIRandomProvider.json');
var IIRelay$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIRelay.sol/IIRelay.json');
var IIRewardEpochSwitchoverTrigger$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIRewardEpochSwitchoverTrigger.sol/IIRewardEpochSwitchoverTrigger.json');
var IIRewardManager$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIRewardManager.sol/IIRewardManager.json');
var IISubmission$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IISubmission.sol/IISubmission.json');
var IISupply = require('./songbird/artifacts/contracts/inflation/interfaces/IISupply.sol/IISupply.json');
var IITokenPool = require('./songbird/artifacts/contracts/tokenPools/interfaces/IITokenPool.sol/IITokenPool.json');
var IIVPContract$3 = require('./songbird/artifacts/contracts/token/interfaces/IIVPContract.sol/IIVPContract.json');
var IIVPToken$3 = require('./songbird/artifacts/contracts/token/interfaces/IIVPToken.sol/IIVPToken.json');
var IIVoterRegistrationTrigger$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIVoterRegistrationTrigger.sol/IIVoterRegistrationTrigger.json');
var IIVoterRegistry$3 = require('./songbird/artifacts/contracts/protocol/interfaces/IIVoterRegistry.sol/IIVoterRegistry.json');
var IIVoterWhitelister = require('./songbird/artifacts/contracts/utils/interfaces/IIVoterWhitelister.sol/IIVoterWhitelister.json');
var IIncreaseManager$3 = require('./songbird/artifacts/contracts/IIncreaseManager.sol/IIncreaseManager.json');
var IInflationGenesis = require('./songbird/artifacts/contracts/genesis/interfaces/IInflationGenesis.sol/IInflationGenesis.json');
var IJsonApi$3 = require('./songbird/artifacts/contracts/IJsonApi.sol/IJsonApi.json');
var IJsonApiVerification$3 = require('./songbird/artifacts/contracts/IJsonApiVerification.sol/IJsonApiVerification.json');
var IPayment$3 = require('./songbird/artifacts/contracts/IPayment.sol/IPayment.json');
var IPaymentVerification$3 = require('./songbird/artifacts/contracts/IPaymentVerification.sol/IPaymentVerification.json');
var IPollingFtso$2 = require('./songbird/artifacts/contracts/IPollingFtso.sol/IPollingFtso.json');
var IPollingManagementGroup$3 = require('./songbird/artifacts/contracts/IPollingManagementGroup.sol/IPollingManagementGroup.json');
var IPriceSubmitter$3 = require('./songbird/artifacts/contracts/IPriceSubmitter.sol/IPriceSubmitter.json');
var IRNat$3 = require('./songbird/artifacts/contracts/IRNat.sol/IRNat.json');
var IRNatAccount$3 = require('./songbird/artifacts/contracts/IRNatAccount.sol/IRNatAccount.json');
var IRandomProvider$3 = require('./songbird/artifacts/contracts/IRandomProvider.sol/IRandomProvider.json');
var IRedemptionTimeExtension$3 = require('./songbird/artifacts/contracts/IRedemptionTimeExtension.sol/IRedemptionTimeExtension.json');
var IReferencedPaymentNonexistence$3 = require('./songbird/artifacts/contracts/IReferencedPaymentNonexistence.sol/IReferencedPaymentNonexistence.json');
var IReferencedPaymentNonexistenceVerification$3 = require('./songbird/artifacts/contracts/IReferencedPaymentNonexistenceVerification.sol/IReferencedPaymentNonexistenceVerification.json');
var IRelay$3 = require('./songbird/artifacts/contracts/IRelay.sol/IRelay.json');
var IRewardManager$3 = require('./songbird/artifacts/contracts/IRewardManager.sol/IRewardManager.json');
var ISubmission$3 = require('./songbird/artifacts/contracts/ISubmission.sol/ISubmission.json');
var ITransferFees$1 = require('./songbird/artifacts/contracts/ITransferFees.sol/ITransferFees.json');
var ITypeTemplate$3 = require('./songbird/artifacts/contracts/fdc/interfaces/ITypeTemplate.sol/ITypeTemplate.json');
var ITypeTemplateVerification$3 = require('./songbird/artifacts/contracts/fdc/interfaces/ITypeTemplateVerification.sol/ITypeTemplateVerification.json');
var IUpdateValidators = require('./songbird/artifacts/contracts/utils/interfaces/IUpdateValidators.sol/IUpdateValidators.json');
var IVPContractEvents$3 = require('./songbird/artifacts/contracts/IVPContractEvents.sol/IVPContractEvents.json');
var IVPToken$3 = require('./songbird/artifacts/contracts/IVPToken.sol/IVPToken.json');
var IValidatorRewardOffersManager$3 = require('./songbird/artifacts/contracts/IValidatorRewardOffersManager.sol/IValidatorRewardOffersManager.json');
var IVoterPreRegistry$3 = require('./songbird/artifacts/contracts/IVoterPreRegistry.sol/IVoterPreRegistry.json');
var IVoterRegistry$3 = require('./songbird/artifacts/contracts/IVoterRegistry.sol/IVoterRegistry.json');
var IVoterWhitelister$3 = require('./songbird/artifacts/contracts/IVoterWhitelister.sol/IVoterWhitelister.json');
var IWNat$3 = require('./songbird/artifacts/contracts/IWNat.sol/IWNat.json');
var IWNatDelegationFee$3 = require('./songbird/artifacts/contracts/IWNatDelegationFee.sol/IWNatDelegationFee.json');
var IWeb2Json$3 = require('./songbird/artifacts/contracts/IWeb2Json.sol/IWeb2Json.json');
var IWeb2JsonVerification$3 = require('./songbird/artifacts/contracts/IWeb2JsonVerification.sol/IWeb2JsonVerification.json');
var IWhitelist$1 = require('./songbird/artifacts/contracts/IWhitelist.sol/IWhitelist.json');
var ProtocolsV2Interface$3 = require('./songbird/artifacts/contracts/ProtocolsV2Interface.sol/ProtocolsV2Interface.json');
var RandomNumberV2Interface$3 = require('./songbird/artifacts/contracts/RandomNumberV2Interface.sol/RandomNumberV2Interface.json');
var RedemptionRequestInfo$3 = require('./songbird/artifacts/contracts/data/RedemptionRequestInfo.sol/RedemptionRequestInfo.json');
var RedemptionTicketInfo$3 = require('./songbird/artifacts/contracts/data/RedemptionTicketInfo.sol/RedemptionTicketInfo.json');
var RewardsV2Interface$3 = require('./songbird/artifacts/contracts/RewardsV2Interface.sol/RewardsV2Interface.json');
var TestFtsoV2Interface$3 = require('./songbird/artifacts/contracts/TestFtsoV2Interface.sol/TestFtsoV2Interface.json');

/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */
/**
 *  The current version of Ethers.
 */
const version = "6.15.0";

/**
 *  Property helper functions.
 *
 *  @_subsection api/utils:Properties  [about-properties]
 */
function checkType(value, type, name) {
    const types = type.split("|").map(t => t.trim());
    for (let i = 0; i < types.length; i++) {
        switch (type) {
            case "any":
                return;
            case "bigint":
            case "boolean":
            case "number":
            case "string":
                if (typeof (value) === type) {
                    return;
                }
        }
    }
    const error = new Error(`invalid value for type ${type}`);
    error.code = "INVALID_ARGUMENT";
    error.argument = `value.${name}`;
    error.value = value;
    throw error;
}
/**
 *  Resolves to a new object that is a copy of %%value%%, but with all
 *  values resolved.
 */
async function resolveProperties(value) {
    const keys = Object.keys(value);
    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
    return results.reduce((accum, v, index) => {
        accum[keys[index]] = v;
        return accum;
    }, {});
}
/**
 *  Assigns the %%values%% to %%target%% as read-only values.
 *
 *  It %%types%% is specified, the values are checked.
 */
function defineProperties(target, values, types) {
    for (let key in values) {
        let value = values[key];
        const type = (types ? types[key] : null);
        if (type) {
            checkType(value, type, key);
        }
        Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
}

/**
 *  All errors in ethers include properties to ensure they are both
 *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).
 *
 *  The [[isError]] function can be used to check the error ``code`` and
 *  provide a type guard for the properties present on that error interface.
 *
 *  @_section: api/utils/errors:Errors  [about-errors]
 */
function stringify(value, seen) {
    if (value == null) {
        return "null";
    }
    if (seen == null) {
        seen = new Set();
    }
    if (typeof (value) === "object") {
        if (seen.has(value)) {
            return "[Circular]";
        }
        seen.add(value);
    }
    if (Array.isArray(value)) {
        return "[ " + (value.map((v) => stringify(v, seen))).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
        const HEX = "0123456789abcdef";
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            result += HEX[value[i] >> 4];
            result += HEX[value[i] & 0xf];
        }
        return result;
    }
    if (typeof (value) === "object" && typeof (value.toJSON) === "function") {
        return stringify(value.toJSON(), seen);
    }
    switch (typeof (value)) {
        case "boolean":
        case "number":
        case "symbol":
            return value.toString();
        case "bigint":
            return BigInt(value).toString();
        case "string":
            return JSON.stringify(value);
        case "object": {
            const keys = Object.keys(value);
            keys.sort();
            return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
        }
    }
    return `[ COULD NOT SERIALIZE ]`;
}
/**
 *  Returns true if the %%error%% matches an error thrown by ethers
 *  that matches the error %%code%%.
 *
 *  In TypeScript environments, this can be used to check that %%error%%
 *  matches an EthersError type, which means the expected properties will
 *  be set.
 *
 *  @See [ErrorCodes](api:ErrorCode)
 *  @example
 *    try {
 *      // code....
 *    } catch (e) {
 *      if (isError(e, "CALL_EXCEPTION")) {
 *          // The Type Guard has validated this object
 *          console.log(e.data);
 *      }
 *    }
 */
function isError(error, code) {
    return (error && error.code === code);
}
/**
 *  Returns true if %%error%% is a [[CallExceptionError].
 */
function isCallException(error) {
    return isError(error, "CALL_EXCEPTION");
}
/**
 *  Returns a new Error configured to the format ethers emits errors, with
 *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties
 *  for the corresponding EthersError.
 *
 *  Each error in ethers includes the version of ethers, a
 *  machine-readable [[ErrorCode]], and depending on %%code%%, additional
 *  required properties. The error message will also include the %%message%%,
 *  ethers version, %%code%% and all additional properties, serialized.
 */
function makeError(message, code, info) {
    let shortMessage = message;
    {
        const details = [];
        if (info) {
            if ("message" in info || "code" in info || "name" in info) {
                throw new Error(`value will overwrite populated values: ${stringify(info)}`);
            }
            for (const key in info) {
                if (key === "shortMessage") {
                    continue;
                }
                const value = (info[key]);
                //                try {
                details.push(key + "=" + stringify(value));
                //                } catch (error: any) {
                //                console.log("MMM", error.message);
                //                    details.push(key + "=[could not serialize object]");
                //                }
            }
        }
        details.push(`code=${code}`);
        details.push(`version=${version}`);
        if (details.length) {
            message += " (" + details.join(", ") + ")";
        }
    }
    let error;
    switch (code) {
        case "INVALID_ARGUMENT":
            error = new TypeError(message);
            break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
            error = new RangeError(message);
            break;
        default:
            error = new Error(message);
    }
    defineProperties(error, { code });
    if (info) {
        Object.assign(error, info);
    }
    if (error.shortMessage == null) {
        defineProperties(error, { shortMessage });
    }
    return error;
}
/**
 *  Throws an EthersError with %%message%%, %%code%% and additional error
 *  %%info%% when %%check%% is falsish..
 *
 *  @see [[api:makeError]]
 */
function assert(check, message, code, info) {
    if (!check) {
        throw makeError(message, code, info);
    }
}
/**
 *  A simple helper to simply ensuring provided arguments match expected
 *  constraints, throwing if not.
 *
 *  In TypeScript environments, the %%check%% has been asserted true, so
 *  any further code does not need additional compile-time checks.
 */
function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value: value });
}
function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
        message = "";
    }
    if (message) {
        message = ": " + message;
    }
    assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
        count: count,
        expectedCount: expectedCount
    });
    assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
        count: count,
        expectedCount: expectedCount
    });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
        // General test for normalize
        /* c8 ignore start */
        if ("test".normalize(form) !== "test") {
            throw new Error("bad");
        }
        ;
        /* c8 ignore stop */
        if (form === "NFD") {
            const check = String.fromCharCode(0xe9).normalize("NFD");
            const expected = String.fromCharCode(0x65, 0x0301);
            /* c8 ignore start */
            if (check !== expected) {
                throw new Error("broken");
            }
            /* c8 ignore stop */
        }
        accum.push(form);
    }
    catch (error) { }
    return accum;
}, []);
/**
 *  Many classes use file-scoped values to guard the constructor,
 *  making it effectively private. This facilitates that pattern
 *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
 *  throwing if not, indicating the %%className%% if provided.
 */
function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
        className = "";
    }
    if (givenGuard !== guard) {
        let method = className, operation = "new";
        if (className) {
            method += ".";
            operation += " " + className;
        }
        assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
            operation
        });
    }
}

/**
 *  Some data helpers.
 *
 *
 *  @_subsection api/utils:Data Helpers  [about-data]
 */
function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
        if (copy) {
            return new Uint8Array(value);
        }
        return value;
    }
    if (typeof (value) === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const result = new Uint8Array((value.length - 2) / 2);
        let offset = 2;
        for (let i = 0; i < result.length; i++) {
            result[i] = parseInt(value.substring(offset, offset + 2), 16);
            offset += 2;
        }
        return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
}
/**
 *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
 *  the original %%value%% is returned; if a copy is required use
 *  [[getBytesCopy]].
 *
 *  @see: getBytesCopy
 */
function getBytes(value, name) {
    return _getBytes(value, name, false);
}
/**
 *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
 *  to prevent any modifications of the returned value from being
 *  reflected elsewhere.
 *
 *  @see: getBytes
 */
function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
}
/**
 *  Returns true if %%value%% is a valid [[HexString]].
 *
 *  If %%length%% is ``true`` or a //number//, it also checks that
 *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
 *  bytes of data (e.g. ``0x1234`` is 2 bytes).
 */
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (typeof (length) === "number" && value.length !== 2 + 2 * length) {
        return false;
    }
    if (length === true && (value.length % 2) !== 0) {
        return false;
    }
    return true;
}
/**
 *  Returns true if %%value%% is a valid representation of arbitrary
 *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
 */
function isBytesLike(value) {
    return (isHexString(value, true) || (value instanceof Uint8Array));
}
const HexCharacters = "0123456789abcdef";
/**
 *  Returns a [[DataHexString]] representation of %%data%%.
 */
function hexlify(data) {
    const bytes = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes.length; i++) {
        const v = bytes[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }
    return result;
}
/**
 *  Returns a [[DataHexString]] by concatenating all values
 *  within %%data%%.
 */
function concat(datas) {
    return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
/**
 *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
 *  offset to the %%end%% offset.
 *
 *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
 */
function dataSlice(data, start, end) {
    const bytes = getBytes(data);
    if (end != null && end > bytes.length) {
        assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
            buffer: bytes, length: bytes.length, offset: end
        });
    }
    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));
}
function zeroPad(data, length, left) {
    const bytes = getBytes(data);
    assert(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(bytes),
        length: length,
        offset: length + 1
    });
    const result = new Uint8Array(length);
    result.fill(0);
    if (left) {
        result.set(bytes, length - bytes.length);
    }
    else {
        result.set(bytes, 0);
    }
    return hexlify(result);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **left**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **values** are in Solidity
 *  (e.g. ``uint128``).
 */
function zeroPadValue(data, length) {
    return zeroPad(data, length, true);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **right**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **bytes** are in Solidity
 *  (e.g. ``bytes16``).
 */
function zeroPadBytes(data, length) {
    return zeroPad(data, length, false);
}

/**
 *  Some mathematic operations.
 *
 *  @_subsection: api/utils:Math Helpers  [about-maths]
 */
const BN_0$4 = BigInt(0);
const BN_1$1 = BigInt(1);
//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
// IEEE 754 support 53-bits of mantissa
const maxValue = 0x1fffffffffffff;
/**
 *  Convert %%value%% from a twos-compliment representation of %%width%%
 *  bits to its value.
 *
 *  If the highest bit is ``1``, the result will be negative.
 */
function fromTwos(_value, _width) {
    const value = getUint(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    assert((value >> width) === BN_0$4, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos", fault: "overflow", value: _value
    });
    // Top bit set; treat as a negative value
    if (value >> (width - BN_1$1)) {
        const mask = (BN_1$1 << width) - BN_1$1;
        return -(((~value) & mask) + BN_1$1);
    }
    return value;
}
/**
 *  Convert %%value%% to a twos-compliment representation of
 *  %%width%% bits.
 *
 *  The result will always be positive.
 */
function toTwos(_value, _width) {
    let value = getBigInt(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    const limit = (BN_1$1 << (width - BN_1$1));
    if (value < BN_0$4) {
        value = -value;
        assert(value <= limit, "too low", "NUMERIC_FAULT", {
            operation: "toTwos", fault: "overflow", value: _value
        });
        const mask = (BN_1$1 << width) - BN_1$1;
        return ((~value) & mask) + BN_1$1;
    }
    else {
        assert(value < limit, "too high", "NUMERIC_FAULT", {
            operation: "toTwos", fault: "overflow", value: _value
        });
    }
    return value;
}
/**
 *  Mask %%value%% with a bitmask of %%bits%% ones.
 */
function mask(_value, _bits) {
    const value = getUint(_value, "value");
    const bits = BigInt(getNumber(_bits, "bits"));
    return value & ((BN_1$1 << bits) - BN_1$1);
}
/**
 *  Gets a BigInt from %%value%%. If it is an invalid value for
 *  a BigInt, then an ArgumentError will be thrown for %%name%%.
 */
function getBigInt(value, name) {
    switch (typeof (value)) {
        case "bigint": return value;
        case "number":
            assertArgument(Number.isInteger(value), "underflow", name || "value", value);
            assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return BigInt(value);
        case "string":
            try {
                if (value === "") {
                    throw new Error("empty string");
                }
                if (value[0] === "-" && value[1] !== "-") {
                    return -BigInt(value.substring(1));
                }
                return BigInt(value);
            }
            catch (e) {
                assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
            }
    }
    assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
/**
 *  Returns %%value%% as a bigint, validating it is valid as a bigint
 *  value and that it is positive.
 */
function getUint(value, name) {
    const result = getBigInt(value, name);
    assert(result >= BN_0$4, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow", operation: "getUint", value
    });
    return result;
}
const Nibbles = "0123456789abcdef";
/*
 * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it
 * is treated as Big Endian data.
 */
function toBigInt(value) {
    if (value instanceof Uint8Array) {
        let result = "0x0";
        for (const v of value) {
            result += Nibbles[v >> 4];
            result += Nibbles[v & 0x0f];
        }
        return BigInt(result);
    }
    return getBigInt(value);
}
/**
 *  Gets a //number// from %%value%%. If it is an invalid value for
 *  a //number//, then an ArgumentError will be thrown for %%name%%.
 */
function getNumber(value, name) {
    switch (typeof (value)) {
        case "bigint":
            assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return Number(value);
        case "number":
            assertArgument(Number.isInteger(value), "underflow", name || "value", value);
            assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return value;
        case "string":
            try {
                if (value === "") {
                    throw new Error("empty string");
                }
                return getNumber(BigInt(value), name);
            }
            catch (e) {
                assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
            }
    }
    assertArgument(false, "invalid numeric value", name || "value", value);
}
/**
 *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
 *  is treated as Big Endian data. Throws if the value is not safe.
 */
function toNumber(value) {
    return getNumber(toBigInt(value));
}
/**
 *  Converts %%value%% to a Big Endian hexstring, optionally padded to
 *  %%width%% bytes.
 */
function toBeHex(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
        // Ensure the value is of even length
        if (result.length % 2) {
            result = "0" + result;
        }
    }
    else {
        const width = getNumber(_width, "width");
        assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: _value
        });
        // Pad the value to the required width
        while (result.length < (width * 2)) {
            result = "0" + result;
        }
    }
    return "0x" + result;
}
/**
 *  Converts %%value%% to a Big Endian Uint8Array.
 */
function toBeArray(_value) {
    const value = getUint(_value, "value");
    if (value === BN_0$4) {
        return new Uint8Array([]);
    }
    let hex = value.toString(16);
    if (hex.length % 2) {
        hex = "0" + hex;
    }
    const result = new Uint8Array(hex.length / 2);
    for (let i = 0; i < result.length; i++) {
        const offset = i * 2;
        result[i] = parseInt(hex.substring(offset, offset + 2), 16);
    }
    return result;
}

/**
 *  Events allow for applications to use the observer pattern, which
 *  allows subscribing and publishing events, outside the normal
 *  execution paths.
 *
 *  @_section api/utils/events:Events  [about-events]
 */
/**
 *  When an [[EventEmitterable]] triggers a [[Listener]], the
 *  callback always ahas one additional argument passed, which is
 *  an **EventPayload**.
 */
class EventPayload {
    /**
     *  The event filter.
     */
    filter;
    /**
     *  The **EventEmitterable**.
     */
    emitter;
    #listener;
    /**
     *  Create a new **EventPayload** for %%emitter%% with
     *  the %%listener%% and for %%filter%%.
     */
    constructor(emitter, listener, filter) {
        this.#listener = listener;
        defineProperties(this, { emitter, filter });
    }
    /**
     *  Unregister the triggered listener for future events.
     */
    async removeListener() {
        if (this.#listener == null) {
            return;
        }
        await this.emitter.off(this.filter, this.#listener);
    }
}

/**
 *  Using strings in Ethereum (or any security-basd system) requires
 *  additional care. These utilities attempt to mitigate some of the
 *  safety issues as well as provide the ability to recover and analyse
 *  strings.
 *
 *  @_subsection api/utils:Strings and UTF-8  [about-strings]
 */
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === "OVERRUN") {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === "OVERLONG") {
        assertArgument(typeof (badCodepoint) === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
/**
 *  A handful of popular, built-in UTF-8 error handling strategies.
 *
 *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
 *  non-canonical (overlong) codepoints (this is the default)
 *
 *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
 *  and accepts non-canonical (overlong) codepoints
 *
 *  **``"replace"``** - replace any illegal UTF-8 sequence with the
 *  UTF-8 replacement character (i.e. ``"\\ufffd"``) and accepts
 *  non-canonical (overlong) codepoints
 *
 *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
 */
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    const bytes = getBytes(_bytes, "bytes");
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
            }
            else {
                i += onError("BAD_PREFIX", i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError("OVERRUN", i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError("MISSING_CONTINUE", i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
/**
 *  Returns the UTF-8 byte representation of %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8Bytes(str, form) {
    assertArgument(typeof (str) === "string", "invalid string value", "str", str);
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            assertArgument(i < str.length && ((c2 & 0xfc00) === 0xdc00), "invalid surrogate pair", "str", str);
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return new Uint8Array(result);
}
//export 
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
/**
 *  Returns the string represented by the UTF-8 data %%bytes%%.
 *
 *  When %%onError%% function is specified, it is called on UTF-8
 *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
 *  (default: [error](Utf8ErrorFuncs))
 */
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

/**
 * @_ignore:
 */
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
const passProperties$1 = ["then"];
const _guard$1 = {};
const resultNames = new WeakMap();
function getNames(result) {
    return resultNames.get(result);
}
function setNames(result, names) {
    resultNames.set(result, names);
}
function throwError(name, error) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error;
    throw wrapped;
}
function toObject(names, items, deep) {
    if (names.indexOf(null) >= 0) {
        return items.map((item, index) => {
            if (item instanceof Result) {
                return toObject(getNames(item), item, deep);
            }
            return item;
        });
    }
    return names.reduce((accum, name, index) => {
        let item = items.getValue(name);
        if (!(name in accum)) {
            if (deep && item instanceof Result) {
                item = toObject(getNames(item), item, deep);
            }
            accum[name] = item;
        }
        return accum;
    }, {});
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
class Result extends Array {
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    #names;
    /**
     *  @private
     */
    constructor(...args) {
        // To properly sub-class Array so the other built-in
        // functions work, the constructor has to behave fairly
        // well. So, in the event we are created via fromItems()
        // we build the read-only Result object we want, but on
        // any other input, we use the default constructor
        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
        const guard = args[0];
        let items = args[1];
        let names = (args[2] || []).slice();
        let wrap = true;
        if (guard !== _guard$1) {
            items = args;
            names = [];
            wrap = false;
        }
        // Can't just pass in ...items since an array of length 1
        // is a special case in the super.
        super(items.length);
        items.forEach((item, index) => { this[index] = item; });
        // Find all unique keys
        const nameCounts = names.reduce((accum, name) => {
            if (typeof (name) === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
        }, (new Map()));
        // Remove any key thats not unique
        setNames(this, Object.freeze(items.map((item, index) => {
            const name = names[index];
            if (name != null && nameCounts.get(name) === 1) {
                return name;
            }
            return null;
        })));
        // Dummy operations to prevent TypeScript from complaining
        this.#names = [];
        if (this.#names == null) {
            void (this.#names);
        }
        if (!wrap) {
            return;
        }
        // A wrapped Result is immutable
        Object.freeze(this);
        // Proxy indices and names so we can trap deferred errors
        const proxy = new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "string") {
                    // Index accessor
                    if (prop.match(/^[0-9]+$/)) {
                        const index = getNumber(prop, "%index");
                        if (index < 0 || index >= this.length) {
                            throw new RangeError("out of result range");
                        }
                        const item = target[index];
                        if (item instanceof Error) {
                            throwError(`index ${index}`, item);
                        }
                        return item;
                    }
                    // Pass important checks (like `then` for Promise) through
                    if (passProperties$1.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    const value = target[prop];
                    if (value instanceof Function) {
                        // Make sure functions work with private variables
                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                        return function (...args) {
                            return value.apply((this === receiver) ? target : this, args);
                        };
                    }
                    else if (!(prop in target)) {
                        // Possible name accessor
                        return target.getValue.apply((this === receiver) ? target : this, [prop]);
                    }
                }
                return Reflect.get(target, prop, receiver);
            }
        });
        setNames(proxy, getNames(this));
        return proxy;
    }
    /**
     *  Returns the Result as a normal Array. If %%deep%%, any children
     *  which are Result objects are also converted to a normal Array.
     *
     *  This will throw if there are any outstanding deferred
     *  errors.
     */
    toArray(deep) {
        const result = [];
        this.forEach((item, index) => {
            if (item instanceof Error) {
                throwError(`index ${index}`, item);
            }
            if (deep && item instanceof Result) {
                item = item.toArray(deep);
            }
            result.push(item);
        });
        return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair. If
     *  %%deep%%, any children which are Result objects are also
     *  converted to an Object.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
    toObject(deep) {
        const names = getNames(this);
        return names.reduce((accum, name, index) => {
            assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
                operation: "toObject()"
            });
            return toObject(names, this, deep);
        }, {});
    }
    /**
     *  @_ignore
     */
    slice(start, end) {
        if (start == null) {
            start = 0;
        }
        if (start < 0) {
            start += this.length;
            if (start < 0) {
                start = 0;
            }
        }
        if (end == null) {
            end = this.length;
        }
        if (end < 0) {
            end += this.length;
            if (end < 0) {
                end = 0;
            }
        }
        if (end > this.length) {
            end = this.length;
        }
        const _names = getNames(this);
        const result = [], names = [];
        for (let i = start; i < end; i++) {
            result.push(this[i]);
            names.push(_names[i]);
        }
        return new Result(_guard$1, result, names);
    }
    /**
     *  @_ignore
     */
    filter(callback, thisArg) {
        const _names = getNames(this);
        const result = [], names = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(_names[i]);
            }
        }
        return new Result(_guard$1, result, names);
    }
    /**
     *  @_ignore
     */
    map(callback, thisArg) {
        const result = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
        }
        return result;
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
    getValue(name) {
        const index = getNames(this).indexOf(name);
        if (index === -1) {
            return undefined;
        }
        const value = this[index];
        if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
    static fromItems(items, keys) {
        return new Result(_guard$1, items, keys);
    }
}
function getValue(value) {
    let bytes = toBeArray(value);
    assert(bytes.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: WordSize, offset: bytes.length });
    if (bytes.length !== WordSize) {
        bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
    }
    return bytes;
}
/**
 *  @_ignore
 */
class Coder {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    name;
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    type;
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    localName;
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    dynamic;
    constructor(name, type, localName, dynamic) {
        defineProperties(this, { name, type, localName, dynamic }, {
            name: "string", type: "string", localName: "string", dynamic: "boolean"
        });
    }
    _throwError(message, value) {
        assertArgument(false, message, this.localName, value);
    }
}
/**
 *  @_ignore
 */
class Writer {
    // An array of WordSize lengthed objects to concatenation
    #data;
    #dataLength;
    constructor() {
        this.#data = [];
        this.#dataLength = 0;
    }
    get data() {
        return concat(this.#data);
    }
    get length() { return this.#dataLength; }
    #writeData(data) {
        this.#data.push(data);
        this.#dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this.#writeData(getBytesCopy(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
    writeBytes(value) {
        let bytes = getBytesCopy(value);
        const paddingOffset = bytes.length % WordSize;
        if (paddingOffset) {
            bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
        }
        return this.#writeData(bytes);
    }
    // Numeric item; pad on the left *to* WordSize
    writeValue(value) {
        return this.#writeData(getValue(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
    writeUpdatableValue() {
        const offset = this.#data.length;
        this.#data.push(Padding);
        this.#dataLength += WordSize;
        return (value) => {
            this.#data[offset] = getValue(value);
        };
    }
}
/**
 *  @_ignore
 */
class Reader {
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    allowLoose;
    #data;
    #offset;
    #bytesRead;
    #parent;
    #maxInflation;
    constructor(data, allowLoose, maxInflation) {
        defineProperties(this, { allowLoose: !!allowLoose });
        this.#data = getBytesCopy(data);
        this.#bytesRead = 0;
        this.#parent = null;
        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;
        this.#offset = 0;
    }
    get data() { return hexlify(this.#data); }
    get dataLength() { return this.#data.length; }
    get consumed() { return this.#offset; }
    get bytes() { return new Uint8Array(this.#data); }
    #incrementBytesRead(count) {
        if (this.#parent) {
            return this.#parent.#incrementBytesRead(count);
        }
        this.#bytesRead += count;
        // Check for excessive inflation (see: #4537)
        assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
            buffer: getBytesCopy(this.#data), offset: this.#offset,
            length: count, info: {
                bytesRead: this.#bytesRead,
                dataLength: this.dataLength
            }
        });
    }
    #peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / WordSize) * WordSize;
        if (this.#offset + alignedLength > this.#data.length) {
            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
                alignedLength = length;
            }
            else {
                assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
                    buffer: getBytesCopy(this.#data),
                    length: this.#data.length,
                    offset: this.#offset + alignedLength
                });
            }
        }
        return this.#data.slice(this.#offset, this.#offset + alignedLength);
    }
    // Create a sub-reader with the same underlying data, but offset
    subReader(offset) {
        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
        reader.#parent = this;
        return reader;
    }
    // Read bytes
    readBytes(length, loose) {
        let bytes = this.#peekBytes(0, length, !!loose);
        this.#incrementBytesRead(length);
        this.#offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    // Read a numeric values
    readValue() {
        return toBigInt(this.readBytes(WordSize));
    }
    readIndex() {
        return toNumber(this.readBytes(WordSize));
    }
}

function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}

const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const u8a = (a) => a instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}

// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        exists(this, false);
        bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);

/**
 *  Cryptographic hashing functions
 *
 *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]
 */
let locked = false;
const _keccak256 = function (data) {
    return keccak_256(data);
};
let __keccak256 = _keccak256;
/**
 *  Compute the cryptographic KECCAK256 hash of %%data%%.
 *
 *  The %%data%% **must** be a data representation, to compute the
 *  hash of UTF-8 data use the [[id]] function.
 *
 *  @returns DataHexstring
 *  @example:
 *    keccak256("0x")
 *    //_result:
 *
 *    keccak256("0x1337")
 *    //_result:
 *
 *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 *    // Strings are assumed to be DataHexString, otherwise it will
 *    // throw. To hash UTF-8 data, see the note above.
 *    keccak256("Hello World")
 *    //_error:
 */
function keccak256(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function () { locked = true; };
keccak256.register = function (func) {
    if (locked) {
        throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
};
Object.freeze(keccak256);

const BN_0$3 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
    //    if (!isHexString(address, 20)) {
    //        logger.throwArgumentError("invalid address", "address", address);
    //    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = getBytes(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));
const safeDigits = 15;
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
const Base36 = (function () {
    const result = {};
    for (let i = 0; i < 36; i++) {
        const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
        result[key] = BigInt(i);
    }
    return result;
})();
function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_0$3;
    for (let i = 0; i < value.length; i++) {
        result = result * BN_36 + Base36[value[i]];
    }
    return result;
}
/**
 *  Returns a normalized and checksumed address for %%address%%.
 *  This accepts non-checksum addresses, checksum addresses and
 *  [[getIcapAddress]] formats.
 *
 *  The checksum in Ethereum uses the capitalization (upper-case
 *  vs lower-case) of the characters within an address to encode
 *  its checksum, which offers, on average, a checksum of 15-bits.
 *
 *  If %%address%% contains both upper-case and lower-case, it is
 *  assumed to already be a checksum address and its checksum is
 *  validated, and if the address fails its expected checksum an
 *  error is thrown.
 *
 *  If you wish the checksum of %%address%% to be ignore, it should
 *  be converted to lower-case (i.e. ``.toLowercase()``) before
 *  being passed in. This should be a very rare situation though,
 *  that you wish to bypass the safegaurds in place to protect
 *  against an address that has been incorrectly copied from another
 *  source.
 *
 *  @example:
 *    // Adds the checksum (via upper-casing specific letters)
 *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
 *    //_result:
 *
 *    // Converts ICAP address and adds checksum
 *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if an address contains mixed case,
 *    // but the checksum fails
 *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_error:
 */
function getAddress(address) {
    assertArgument(typeof (address) === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (!address.startsWith("0x")) {
            address = "0x" + address;
        }
        const result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
        return result;
    }
    // Maybe ICAP? (we only support direct mode)
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
        let result = fromBase36(address.substring(4)).toString(16);
        while (result.length < 40) {
            result = "0" + result;
        }
        return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address);
}

/**
 *  Returns true if %%value%% is an object which implements the
 *  [[Addressable]] interface.
 *
 *  @example:
 *    // Wallets and AbstractSigner sub-classes
 *    isAddressable(Wallet.createRandom())
 *    //_result:
 *
 *    // Contracts
 *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
 *    isAddressable(contract)
 *    //_result:
 */
function isAddressable(value) {
    return (value && typeof (value.getAddress) === "function");
}
async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === "0x0000000000000000000000000000000000000000") {
        assert(typeof (target) !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
        assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
    }
    return getAddress(result);
}
/**
 *  Resolves to an address for the %%target%%, which may be any
 *  supported address type, an [[Addressable]] or a Promise which
 *  resolves to an address.
 *
 *  If an ENS name is provided, but that name has not been correctly
 *  configured a [[UnconfiguredNameError]] is thrown.
 *
 *  @example:
 *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
 *
 *    // Addresses are return synchronously
 *    resolveAddress(addr, provider)
 *    //_result:
 *
 *    // Address promises are resolved asynchronously
 *    resolveAddress(Promise.resolve(addr))
 *    //_result:
 *
 *    // ENS names are resolved asynchronously
 *    resolveAddress("dai.tokens.ethers.eth", provider)
 *    //_result:
 *
 *    // Addressable objects are resolved asynchronously
 *    contract = new Contract(addr, [ ])
 *    resolveAddress(contract, provider)
 *    //_result:
 *
 *    // Unconfigured ENS names reject
 *    resolveAddress("nothing-here.ricmoo.eth", provider)
 *    //_error:
 *
 *    // ENS names require a NameResolver object passed in
 *    // (notice the provider was omitted)
 *    resolveAddress("nothing-here.ricmoo.eth")
 *    //_error:
 */
function resolveAddress(target, resolver) {
    if (typeof (target) === "string") {
        if (target.match(/^0x[0-9a-f]{40}$/i)) {
            return getAddress(target);
        }
        assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
        return checkAddress(target, resolver.resolveName(target));
    }
    else if (isAddressable(target)) {
        return checkAddress(target, target.getAddress());
    }
    else if (target && typeof (target.then) === "function") {
        return checkAddress(target, target);
    }
    assertArgument(false, "unsupported addressable value", "target", target);
}

/**
 *  A Typed object allows a value to have its type explicitly
 *  specified.
 *
 *  For example, in Solidity, the value ``45`` could represent a
 *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent
 *  a ``bytes2`` or ``bytes``.
 *
 *  Since JavaScript has no meaningful way to explicitly inform any
 *  APIs which what the type is, this allows transparent interoperation
 *  with Soldity.
 *
 *  @_subsection: api/abi:Typed Values
 */
const _gaurd = {};
function n(value, width) {
    let signed = false;
    if (width < 0) {
        signed = true;
        width *= -1;
    }
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b(value, size) {
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, `bytes${(size) ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
/**
 *  The **Typed** class to wrap values providing explicit type information.
 */
class Typed {
    /**
     *  The type, as a Solidity-compatible type.
     */
    type;
    /**
     *  The actual value.
     */
    value;
    #options;
    /**
     *  @_ignore:
     */
    _typedSymbol;
    /**
     *  @_ignore:
     */
    constructor(gaurd, type, value, options) {
        if (options == null) {
            options = null;
        }
        assertPrivate(_gaurd, gaurd, "Typed");
        defineProperties(this, { _typedSymbol, type, value });
        this.#options = options;
        // Check the value is valid
        this.format();
    }
    /**
     *  Format the type as a Human-Readable type.
     */
    format() {
        if (this.type === "array") {
            throw new Error("");
        }
        else if (this.type === "dynamicArray") {
            throw new Error("");
        }
        else if (this.type === "tuple") {
            return `tuple(${this.value.map((v) => v.format()).join(",")})`;
        }
        return this.type;
    }
    /**
     *  The default value returned by this type.
     */
    defaultValue() {
        return 0;
    }
    /**
     *  The minimum value for numeric types.
     */
    minValue() {
        return 0;
    }
    /**
     *  The maximum value for numeric types.
     */
    maxValue() {
        return 0;
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
     */
    isBigInt() {
        return !!(this.type.match(/^u?int[0-9]+$/));
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
     */
    isData() {
        return this.type.startsWith("bytes");
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
     */
    isString() {
        return (this.type === "string");
    }
    /**
     *  Returns the tuple name, if this is a tuple. Throws otherwise.
     */
    get tupleName() {
        if (this.type !== "tuple") {
            throw TypeError("not a tuple");
        }
        return this.#options;
    }
    // Returns the length of this type as an array
    // - `null` indicates the length is unforced, it could be dynamic
    // - `-1` indicates the length is dynamic
    // - any other value indicates it is a static array and is its length
    /**
     *  Returns the length of the array type or ``-1`` if it is dynamic.
     *
     *  Throws if the type is not an array.
     */
    get arrayLength() {
        if (this.type !== "array") {
            throw TypeError("not an array");
        }
        if (this.#options === true) {
            return -1;
        }
        if (this.#options === false) {
            return (this.value).length;
        }
        return null;
    }
    /**
     *  Returns a new **Typed** of %%type%% with the %%value%%.
     */
    static from(type, value) {
        return new Typed(_gaurd, type, value);
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static uint8(v) { return n(v, 8); }
    /**
     *  Return a new ``uint16`` type for %%v%%.
     */
    static uint16(v) { return n(v, 16); }
    /**
     *  Return a new ``uint24`` type for %%v%%.
     */
    static uint24(v) { return n(v, 24); }
    /**
     *  Return a new ``uint32`` type for %%v%%.
     */
    static uint32(v) { return n(v, 32); }
    /**
     *  Return a new ``uint40`` type for %%v%%.
     */
    static uint40(v) { return n(v, 40); }
    /**
     *  Return a new ``uint48`` type for %%v%%.
     */
    static uint48(v) { return n(v, 48); }
    /**
     *  Return a new ``uint56`` type for %%v%%.
     */
    static uint56(v) { return n(v, 56); }
    /**
     *  Return a new ``uint64`` type for %%v%%.
     */
    static uint64(v) { return n(v, 64); }
    /**
     *  Return a new ``uint72`` type for %%v%%.
     */
    static uint72(v) { return n(v, 72); }
    /**
     *  Return a new ``uint80`` type for %%v%%.
     */
    static uint80(v) { return n(v, 80); }
    /**
     *  Return a new ``uint88`` type for %%v%%.
     */
    static uint88(v) { return n(v, 88); }
    /**
     *  Return a new ``uint96`` type for %%v%%.
     */
    static uint96(v) { return n(v, 96); }
    /**
     *  Return a new ``uint104`` type for %%v%%.
     */
    static uint104(v) { return n(v, 104); }
    /**
     *  Return a new ``uint112`` type for %%v%%.
     */
    static uint112(v) { return n(v, 112); }
    /**
     *  Return a new ``uint120`` type for %%v%%.
     */
    static uint120(v) { return n(v, 120); }
    /**
     *  Return a new ``uint128`` type for %%v%%.
     */
    static uint128(v) { return n(v, 128); }
    /**
     *  Return a new ``uint136`` type for %%v%%.
     */
    static uint136(v) { return n(v, 136); }
    /**
     *  Return a new ``uint144`` type for %%v%%.
     */
    static uint144(v) { return n(v, 144); }
    /**
     *  Return a new ``uint152`` type for %%v%%.
     */
    static uint152(v) { return n(v, 152); }
    /**
     *  Return a new ``uint160`` type for %%v%%.
     */
    static uint160(v) { return n(v, 160); }
    /**
     *  Return a new ``uint168`` type for %%v%%.
     */
    static uint168(v) { return n(v, 168); }
    /**
     *  Return a new ``uint176`` type for %%v%%.
     */
    static uint176(v) { return n(v, 176); }
    /**
     *  Return a new ``uint184`` type for %%v%%.
     */
    static uint184(v) { return n(v, 184); }
    /**
     *  Return a new ``uint192`` type for %%v%%.
     */
    static uint192(v) { return n(v, 192); }
    /**
     *  Return a new ``uint200`` type for %%v%%.
     */
    static uint200(v) { return n(v, 200); }
    /**
     *  Return a new ``uint208`` type for %%v%%.
     */
    static uint208(v) { return n(v, 208); }
    /**
     *  Return a new ``uint216`` type for %%v%%.
     */
    static uint216(v) { return n(v, 216); }
    /**
     *  Return a new ``uint224`` type for %%v%%.
     */
    static uint224(v) { return n(v, 224); }
    /**
     *  Return a new ``uint232`` type for %%v%%.
     */
    static uint232(v) { return n(v, 232); }
    /**
     *  Return a new ``uint240`` type for %%v%%.
     */
    static uint240(v) { return n(v, 240); }
    /**
     *  Return a new ``uint248`` type for %%v%%.
     */
    static uint248(v) { return n(v, 248); }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint256(v) { return n(v, 256); }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint(v) { return n(v, 256); }
    /**
     *  Return a new ``int8`` type for %%v%%.
     */
    static int8(v) { return n(v, -8); }
    /**
     *  Return a new ``int16`` type for %%v%%.
     */
    static int16(v) { return n(v, -16); }
    /**
     *  Return a new ``int24`` type for %%v%%.
     */
    static int24(v) { return n(v, -24); }
    /**
     *  Return a new ``int32`` type for %%v%%.
     */
    static int32(v) { return n(v, -32); }
    /**
     *  Return a new ``int40`` type for %%v%%.
     */
    static int40(v) { return n(v, -40); }
    /**
     *  Return a new ``int48`` type for %%v%%.
     */
    static int48(v) { return n(v, -48); }
    /**
     *  Return a new ``int56`` type for %%v%%.
     */
    static int56(v) { return n(v, -56); }
    /**
     *  Return a new ``int64`` type for %%v%%.
     */
    static int64(v) { return n(v, -64); }
    /**
     *  Return a new ``int72`` type for %%v%%.
     */
    static int72(v) { return n(v, -72); }
    /**
     *  Return a new ``int80`` type for %%v%%.
     */
    static int80(v) { return n(v, -80); }
    /**
     *  Return a new ``int88`` type for %%v%%.
     */
    static int88(v) { return n(v, -88); }
    /**
     *  Return a new ``int96`` type for %%v%%.
     */
    static int96(v) { return n(v, -96); }
    /**
     *  Return a new ``int104`` type for %%v%%.
     */
    static int104(v) { return n(v, -104); }
    /**
     *  Return a new ``int112`` type for %%v%%.
     */
    static int112(v) { return n(v, -112); }
    /**
     *  Return a new ``int120`` type for %%v%%.
     */
    static int120(v) { return n(v, -120); }
    /**
     *  Return a new ``int128`` type for %%v%%.
     */
    static int128(v) { return n(v, -128); }
    /**
     *  Return a new ``int136`` type for %%v%%.
     */
    static int136(v) { return n(v, -136); }
    /**
     *  Return a new ``int144`` type for %%v%%.
     */
    static int144(v) { return n(v, -144); }
    /**
     *  Return a new ``int52`` type for %%v%%.
     */
    static int152(v) { return n(v, -152); }
    /**
     *  Return a new ``int160`` type for %%v%%.
     */
    static int160(v) { return n(v, -160); }
    /**
     *  Return a new ``int168`` type for %%v%%.
     */
    static int168(v) { return n(v, -168); }
    /**
     *  Return a new ``int176`` type for %%v%%.
     */
    static int176(v) { return n(v, -176); }
    /**
     *  Return a new ``int184`` type for %%v%%.
     */
    static int184(v) { return n(v, -184); }
    /**
     *  Return a new ``int92`` type for %%v%%.
     */
    static int192(v) { return n(v, -192); }
    /**
     *  Return a new ``int200`` type for %%v%%.
     */
    static int200(v) { return n(v, -200); }
    /**
     *  Return a new ``int208`` type for %%v%%.
     */
    static int208(v) { return n(v, -208); }
    /**
     *  Return a new ``int216`` type for %%v%%.
     */
    static int216(v) { return n(v, -216); }
    /**
     *  Return a new ``int224`` type for %%v%%.
     */
    static int224(v) { return n(v, -224); }
    /**
     *  Return a new ``int232`` type for %%v%%.
     */
    static int232(v) { return n(v, -232); }
    /**
     *  Return a new ``int240`` type for %%v%%.
     */
    static int240(v) { return n(v, -240); }
    /**
     *  Return a new ``int248`` type for %%v%%.
     */
    static int248(v) { return n(v, -248); }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int256(v) { return n(v, -256); }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int(v) { return n(v, -256); }
    /**
     *  Return a new ``bytes1`` type for %%v%%.
     */
    static bytes1(v) { return b(v, 1); }
    /**
     *  Return a new ``bytes2`` type for %%v%%.
     */
    static bytes2(v) { return b(v, 2); }
    /**
     *  Return a new ``bytes3`` type for %%v%%.
     */
    static bytes3(v) { return b(v, 3); }
    /**
     *  Return a new ``bytes4`` type for %%v%%.
     */
    static bytes4(v) { return b(v, 4); }
    /**
     *  Return a new ``bytes5`` type for %%v%%.
     */
    static bytes5(v) { return b(v, 5); }
    /**
     *  Return a new ``bytes6`` type for %%v%%.
     */
    static bytes6(v) { return b(v, 6); }
    /**
     *  Return a new ``bytes7`` type for %%v%%.
     */
    static bytes7(v) { return b(v, 7); }
    /**
     *  Return a new ``bytes8`` type for %%v%%.
     */
    static bytes8(v) { return b(v, 8); }
    /**
     *  Return a new ``bytes9`` type for %%v%%.
     */
    static bytes9(v) { return b(v, 9); }
    /**
     *  Return a new ``bytes10`` type for %%v%%.
     */
    static bytes10(v) { return b(v, 10); }
    /**
     *  Return a new ``bytes11`` type for %%v%%.
     */
    static bytes11(v) { return b(v, 11); }
    /**
     *  Return a new ``bytes12`` type for %%v%%.
     */
    static bytes12(v) { return b(v, 12); }
    /**
     *  Return a new ``bytes13`` type for %%v%%.
     */
    static bytes13(v) { return b(v, 13); }
    /**
     *  Return a new ``bytes14`` type for %%v%%.
     */
    static bytes14(v) { return b(v, 14); }
    /**
     *  Return a new ``bytes15`` type for %%v%%.
     */
    static bytes15(v) { return b(v, 15); }
    /**
     *  Return a new ``bytes16`` type for %%v%%.
     */
    static bytes16(v) { return b(v, 16); }
    /**
     *  Return a new ``bytes17`` type for %%v%%.
     */
    static bytes17(v) { return b(v, 17); }
    /**
     *  Return a new ``bytes18`` type for %%v%%.
     */
    static bytes18(v) { return b(v, 18); }
    /**
     *  Return a new ``bytes19`` type for %%v%%.
     */
    static bytes19(v) { return b(v, 19); }
    /**
     *  Return a new ``bytes20`` type for %%v%%.
     */
    static bytes20(v) { return b(v, 20); }
    /**
     *  Return a new ``bytes21`` type for %%v%%.
     */
    static bytes21(v) { return b(v, 21); }
    /**
     *  Return a new ``bytes22`` type for %%v%%.
     */
    static bytes22(v) { return b(v, 22); }
    /**
     *  Return a new ``bytes23`` type for %%v%%.
     */
    static bytes23(v) { return b(v, 23); }
    /**
     *  Return a new ``bytes24`` type for %%v%%.
     */
    static bytes24(v) { return b(v, 24); }
    /**
     *  Return a new ``bytes25`` type for %%v%%.
     */
    static bytes25(v) { return b(v, 25); }
    /**
     *  Return a new ``bytes26`` type for %%v%%.
     */
    static bytes26(v) { return b(v, 26); }
    /**
     *  Return a new ``bytes27`` type for %%v%%.
     */
    static bytes27(v) { return b(v, 27); }
    /**
     *  Return a new ``bytes28`` type for %%v%%.
     */
    static bytes28(v) { return b(v, 28); }
    /**
     *  Return a new ``bytes29`` type for %%v%%.
     */
    static bytes29(v) { return b(v, 29); }
    /**
     *  Return a new ``bytes30`` type for %%v%%.
     */
    static bytes30(v) { return b(v, 30); }
    /**
     *  Return a new ``bytes31`` type for %%v%%.
     */
    static bytes31(v) { return b(v, 31); }
    /**
     *  Return a new ``bytes32`` type for %%v%%.
     */
    static bytes32(v) { return b(v, 32); }
    /**
     *  Return a new ``address`` type for %%v%%.
     */
    static address(v) { return new Typed(_gaurd, "address", v); }
    /**
     *  Return a new ``bool`` type for %%v%%.
     */
    static bool(v) { return new Typed(_gaurd, "bool", !!v); }
    /**
     *  Return a new ``bytes`` type for %%v%%.
     */
    static bytes(v) { return new Typed(_gaurd, "bytes", v); }
    /**
     *  Return a new ``string`` type for %%v%%.
     */
    static string(v) { return new Typed(_gaurd, "string", v); }
    /**
     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
     */
    static array(v, dynamic) {
        throw new Error("not implemented yet");
    }
    /**
     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
     */
    static tuple(v, name) {
        throw new Error("not implemented yet");
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static overrides(v) {
        return new Typed(_gaurd, "overrides", Object.assign({}, v));
    }
    /**
     *  Returns true only if %%value%% is a [[Typed]] instance.
     */
    static isTyped(value) {
        return (value
            && typeof (value) === "object"
            && "_typedSymbol" in value
            && value._typedSymbol === _typedSymbol);
    }
    /**
     *  If the value is a [[Typed]] instance, validates the underlying value
     *  and returns it, otherwise returns value directly.
     *
     *  This is useful for functions that with to accept either a [[Typed]]
     *  object or values.
     */
    static dereference(value, type) {
        if (Typed.isTyped(value)) {
            if (value.type !== type) {
                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
            }
            return value.value;
        }
        return value;
    }
}

/**
 *  @_ignore
 */
class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, _value) {
        let value = Typed.dereference(_value, "string");
        try {
            value = getAddress(value);
        }
        catch (error) {
            return this._throwError(error.message, _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(toBeHex(reader.readValue(), 20));
    }
}

/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
class AnonymousCoder extends Coder {
    coder;
    constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

/**
 *  @_ignore
 */
function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
            assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
            unique[name] = true;
            return values[name];
        });
    }
    else {
        assertArgument(false, "invalid tuple value", "tuple", values);
    }
    assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
    let staticWriter = new Writer();
    let dynamicWriter = new Writer();
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
/**
 *  @_ignore
 */
function unpack(reader, coders) {
    let values = [];
    let keys = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readIndex();
            let offsetReader = baseReader.subReader(offset);
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (isError(error, "BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (isError(error, "BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value == undefined) {
            throw new Error("investigate");
        }
        values.push(value);
        keys.push(coder.localName || null);
    });
    return Result.fromItems(values, keys);
}
/**
 *  @_ignore
 */
class ArrayCoder extends Coder {
    coder;
    length;
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        defineProperties(this, { coder, length });
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, _value) {
        const value = Typed.dereference(_value, "array");
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        assertArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readIndex();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
    }
}

/**
 *  @_ignore
 */
class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, _value) {
        const value = Typed.dereference(_value, "bool");
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return !!reader.readValue();
    }
}

/**
 *  @_ignore
 */
class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = getBytesCopy(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
    }
}
/**
 *  @_ignore
 */
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return hexlify(super.decode(reader));
    }
}

/**
 *  @_ignore
 */
class FixedBytesCoder extends Coder {
    size;
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        defineProperties(this, { size }, { size: "number" });
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, _value) {
        let data = getBytesCopy(Typed.dereference(_value, this.type));
        if (data.length !== this.size) {
            this._throwError("incorrect data length", _value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return hexlify(reader.readBytes(this.size));
    }
}

const Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
    }
    decode(reader) {
        reader.readBytes(0);
        return null;
    }
}

const BN_0$2 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  @_ignore
 */
class NumberCoder extends Coder {
    size;
    signed;
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
    }
    defaultValue() {
        return 0;
    }
    encode(writer, _value) {
        let value = getBigInt(Typed.dereference(_value, this.type));
        // Check bounds are safe for encoding
        let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
        if (this.signed) {
            let bounds = mask(maxUintValue, (this.size * 8) - 1);
            if (value > bounds || value < -(bounds + BN_1)) {
                this._throwError("value out-of-bounds", _value);
            }
            value = toTwos(value, 8 * WordSize);
        }
        else if (value < BN_0$2 || value > mask(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        let value = mask(reader.readValue(), this.size * 8);
        if (this.signed) {
            value = fromTwos(value, this.size * 8);
        }
        return value;
    }
}

/**
 *  @_ignore
 */
class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, _value) {
        return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

/**
 *  @_ignore
 */
class TupleCoder extends Coder {
    coders;
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        defineProperties(this, { coders: Object.freeze(coders.slice()) });
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, _value) {
        const value = Typed.dereference(_value, "tuple");
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return unpack(reader, this.coders);
    }
}

function accessSetify(addr, storageKeys) {
    return {
        address: getAddress(addr),
        storageKeys: storageKeys.map((storageKey, index) => {
            assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
            return storageKey.toLowerCase();
        })
    };
}
/**
 *  Returns a [[AccessList]] from any ethers-supported access-list structure.
 */
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
                return accessSetify(set[0], set[1]);
            }
            assertArgument(set != null && typeof (set) === "object", "invalid address-slot set", "value", value);
            return accessSetify(set.address, set.storageKeys);
        });
    }
    assertArgument(value != null && typeof (value) === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}

/**
 *  A simple hashing function which operates on UTF-8 strings to
 *  compute an 32-byte identifier.
 *
 *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
 *  the [[keccak256]].
 *
 *  @example:
 *    id("hello world")
 *    //_result:
 */
function id(value) {
    return keccak256(toUtf8Bytes(value));
}

/**
 *  A fragment is a single item from an ABI, which may represent any of:
 *
 *  - [Functions](FunctionFragment)
 *  - [Events](EventFragment)
 *  - [Constructors](ConstructorFragment)
 *  - Custom [Errors](ErrorFragment)
 *  - [Fallback or Receive](FallbackFragment) functions
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
    const result = new Set();
    items.forEach((k) => result.add(k));
    return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
// Visibility Keywords
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
// All Keywords
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
// Single character tokens
const SimpleTokens = {
    "(": "OPEN_PAREN", ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET", "]": "CLOSE_BRACKET",
    ",": "COMMA", "@": "AT"
};
// Parser regexes to consume the next token
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
    #offset;
    #tokens;
    get offset() { return this.#offset; }
    get length() { return this.#tokens.length - this.#offset; }
    constructor(tokens) {
        this.#offset = 0;
        this.#tokens = tokens.slice();
    }
    clone() { return new TokenString(this.#tokens); }
    reset() { this.#offset = 0; }
    #subTokenString(from = 0, to = 0) {
        return new TokenString(this.#tokens.slice(from, to).map((t) => {
            return Object.freeze(Object.assign({}, t, {
                match: (t.match - from),
                linkBack: (t.linkBack - from),
                linkNext: (t.linkNext - from),
            }));
        }));
    }
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
    popType(type) {
        if (this.peek().type !== type) {
            const top = this.peek();
            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
        }
        return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
    popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = this.#subTokenString(this.#offset + 1, top.match + 1);
        this.#offset = top.match + 1;
        return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
    popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = [];
        while (this.#offset < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(this.#subTokenString(this.#offset + 1, link));
            this.#offset = link;
        }
        this.#offset = top.match + 1;
        return result;
    }
    // Returns the top Token, throwing if out of tokens
    peek() {
        if (this.#offset >= this.#tokens.length) {
            throw new Error("out-of-bounds");
        }
        return this.#tokens[this.#offset];
    }
    // Returns the next value, if it is a keyword in `allowed`
    peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return (top != null && allowed.has(top)) ? top : null;
    }
    // Returns the value of the next token if it is `type`
    peekType(type) {
        if (this.length === 0) {
            return null;
        }
        const top = this.peek();
        return (top.type === type) ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
    pop() {
        const result = this.peek();
        this.#offset++;
        return result;
    }
    toString() {
        const tokens = [];
        for (let i = this.#offset; i < this.#tokens.length; i++) {
            const token = this.#tokens[i];
            tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
    }
}
function lex(text) {
    const tokens = [];
    const throwError = (message) => {
        const token = (offset < text.length) ? JSON.stringify(text[offset]) : "$EOI";
        throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
        // Strip off any leading whitespace
        let cur = text.substring(offset);
        let match = cur.match(regexWhitespacePrefix);
        if (match) {
            offset += match[1].length;
            cur = text.substring(offset);
        }
        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
        tokens.push(token);
        let type = (SimpleTokens[cur[0]] || "");
        if (type) {
            token.type = type;
            token.text = cur[0];
            offset++;
            if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
            }
            else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                    throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                (tokens[token.match]).match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
            }
            else if (type === "COMMA") {
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
            }
            else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
            }
            else if (type === "CLOSE_BRACKET") {
                // Remove the CLOSE_BRACKET
                let suffix = tokens.pop().text;
                if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
                    const value = tokens.pop().text;
                    suffix = value + suffix;
                    (tokens[tokens.length - 1]).value = getNumber(value);
                }
                if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
                    throw new Error("missing opening bracket");
                }
                (tokens[tokens.length - 1]).text += suffix;
            }
            continue;
        }
        match = cur.match(regexIdPrefix);
        if (match) {
            token.text = match[1];
            offset += token.text.length;
            if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
            }
            if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
            }
            token.type = "ID";
            continue;
        }
        match = cur.match(regexNumberPrefix);
        if (match) {
            token.text = match[1];
            token.type = "NUMBER";
            offset += token.text.length;
            continue;
        }
        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
        if (set.has(key)) {
            included.push(key);
        }
    }
    if (included.length > 1) {
        throw new Error(`conflicting types: ${included.join(", ")}`);
    }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
        const keyword = tokens.pop().text;
        if (keyword !== type) {
            throw new Error(`expected ${type}, got ${keyword}`);
        }
    }
    return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
    const keywords = new Set();
    while (true) {
        const keyword = tokens.peekType("KEYWORD");
        if (keyword == null || (allowed && !allowed.has(keyword))) {
            break;
        }
        tokens.pop();
        if (keywords.has(keyword)) {
            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
        }
        keywords.add(keyword);
    }
    return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    // Detect conflicting modifiers
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    // Process mutability states
    if (modifiers.has("view")) {
        return "view";
    }
    if (modifiers.has("pure")) {
        return "pure";
    }
    if (modifiers.has("payable")) {
        return "payable";
    }
    if (modifiers.has("nonpayable")) {
        return "nonpayable";
    }
    // Process legacy `constant` last
    if (modifiers.has("constant")) {
        return "view";
    }
    return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
        tokens.pop();
        if (tokens.peekType("NUMBER")) {
            return getBigInt(tokens.pop().text);
        }
        throw new Error("invalid gas");
    }
    return null;
}
function consumeEoi(tokens) {
    if (tokens.length) {
        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
    }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
    const match = type.match(regexType);
    assertArgument(match, "invalid type", "type", type);
    if (type === "uint") {
        return "uint256";
    }
    if (type === "int") {
        return "int256";
    }
    if (match[2]) {
        // bytesXX
        const length = parseInt(match[2]);
        assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
    }
    else if (match[3]) {
        // intXX or uintXX
        const size = parseInt(match[3]);
        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, "invalid numeric width", "type", type);
    }
    return type;
}
// Make the Fragment constructors effectively private
const _guard = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
 */
class ParamType {
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    name;
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    type;
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    baseType;
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    indexed;
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    components;
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    arrayLength;
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    arrayChildren;
    /**
     *  @private
     */
    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
        assertPrivate(guard, _guard, "ParamType");
        Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
        if (components) {
            components = Object.freeze(components.slice());
        }
        if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
            }
        }
        else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
        }
        if (baseType === "tuple") {
            if (components == null) {
                throw new Error("");
            }
        }
        else if (components != null) {
            throw new Error("");
        }
        defineProperties(this, {
            name, type, baseType, indexed, components, arrayLength, arrayChildren
        });
    }
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            const name = this.name || "";
            if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
                return JSON.stringify(result);
            }
            const result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.isTuple()) {
                result.components = this.components.map((c) => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
        }
        else {
            if (this.isTuple()) {
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === "full") ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== "sighash") {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === "full" && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
    isArray() {
        return (this.baseType === "array");
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
    isTuple() {
        return (this.baseType === "tuple");
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
    isIndexable() {
        return (this.indexed != null);
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
    walk(value, process) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v) => (_this.arrayChildren.walk(v, process)));
        }
        if (this.isTuple()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => (_this.components[i].walk(v, process)));
        }
        return process(this.type, value);
    }
    #walkAsync(promises, value, process, setValue) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const childType = this.arrayChildren;
            const result = value.slice();
            result.forEach((value, index) => {
                childType.#walkAsync(promises, value, process, (value) => {
                    result[index] = value;
                });
            });
            setValue(result);
            return;
        }
        if (this.isTuple()) {
            const components = this.components;
            // Convert the object into an array
            let result;
            if (Array.isArray(value)) {
                result = value.slice();
            }
            else {
                if (value == null || typeof (value) !== "object") {
                    throw new Error("invalid tuple value");
                }
                result = components.map((param) => {
                    if (!param.name) {
                        throw new Error("cannot use object value with unnamed components");
                    }
                    if (!(param.name in value)) {
                        throw new Error(`missing value for component ${param.name}`);
                    }
                    return value[param.name];
                });
            }
            if (result.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            result.forEach((value, index) => {
                components[index].#walkAsync(promises, value, process, (value) => {
                    result[index] = value;
                });
            });
            setValue(result);
            return;
        }
        const result = process(this.type, value);
        if (result.then) {
            promises.push((async function () { setValue(await result); })());
        }
        else {
            setValue(result);
        }
    }
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS names by walking and resolving each
     *  ``"address"`` type.
     */
    async walkAsync(value, process) {
        const promises = [];
        const result = [value];
        this.#walkAsync(promises, value, process, (value) => {
            result[0] = value;
        });
        if (promises.length) {
            await Promise.all(promises);
        }
        return result[0];
    }
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    static from(obj, allowIndexed) {
        if (ParamType.isParamType(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ParamType.from(lex(obj), allowIndexed);
            }
            catch (error) {
                assertArgument(false, "invalid param type", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            let type = "", baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
                // Tuple
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
            }
            else {
                // Normal
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
            }
            // Check for Array
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop(); //arrays[i];
                arrayChildren = new ParamType(_guard, "", type, baseType, null, comps, arrayLength, arrayChildren);
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
            }
            let indexed = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
                if (!allowIndexed) {
                    throw new Error("");
                }
                indexed = true;
            }
            const name = (obj.peekType("ID") ? obj.pop().text : "");
            if (obj.length) {
                throw new Error("leftover tokens");
            }
            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        assertArgument(!name || (typeof (name) === "string" && name.match(regexId)), "invalid name", "obj.name", name);
        let indexed = obj.indexed;
        if (indexed != null) {
            assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
            indexed = !!indexed;
        }
        let type = obj.type;
        let arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components
            });
            return new ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;
            const tuple = new ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
            // @TODO: use lexer to validate and normalize type
            return tuple;
        }
        type = verifyBasicType(obj.type);
        return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
    static isParamType(value) {
        return (value && value[internal$1] === ParamTypeInternal);
    }
}
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
class Fragment {
    /**
     *  The type of the fragment.
     */
    type;
    /**
     *  The inputs for the fragment.
     */
    inputs;
    /**
     *  @private
     */
    constructor(guard, type, inputs) {
        assertPrivate(guard, _guard, "Fragment");
        inputs = Object.freeze(inputs.slice());
        defineProperties(this, { type, inputs });
    }
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            // Try parsing JSON...
            try {
                Fragment.from(JSON.parse(obj));
            }
            catch (e) { }
            // ...otherwise, use the human-readable lexer
            return Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
            // Human-readable ABI (already lexed)
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
        }
        else if (typeof (obj) === "object") {
            // JSON ABI
            switch (obj.type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
            assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            });
        }
        assertArgument(false, "unsupported frgament object", "obj", obj);
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
    static isConstructor(value) {
        return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
    static isError(value) {
        return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
    static isEvent(value) {
        return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
    static isFunction(value) {
        return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
    static isStruct(value) {
        return StructFragment.isFragment(value);
    }
}
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
class NamedFragment extends Fragment {
    /**
     *  The name of the fragment.
     */
    name;
    /**
     *  @private
     */
    constructor(guard, type, name, inputs) {
        super(guard, type, inputs);
        assertArgument(typeof (name) === "string" && name.match(regexId), "invalid identifier", "name", name);
        inputs = Object.freeze(inputs.slice());
        defineProperties(this, { name });
    }
}
function joinParams(format, params) {
    return "(" + params.map((p) => p.format(format)).join((format === "full") ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
class ErrorFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
    }
    /**
     *  The Custom Error selector.
     */
    get selector() {
        return id(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("error");
        }
        result.push(this.name + joinParams(format, this.inputs));
        return result.join(" ");
    }
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ErrorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            return ErrorFragment.from(lex(obj));
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new ErrorFragment(_guard, name, inputs);
        }
        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === ErrorFragmentInternal);
    }
}
/**
 *  A Fragment which represents an Event.
 */
class EventFragment extends NamedFragment {
    /**
     *  Whether this event is anonymous.
     */
    anonymous;
    /**
     *  @private
     */
    constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
        defineProperties(this, { anonymous });
    }
    /**
     *  The Event topic hash.
     */
    get topicHash() {
        return id(this.format("sighash"));
    }
    /**
     *  Returns a string representation of this event as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("event");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
        }
        return result.join(" ");
    }
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
    static getTopicHash(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new EventFragment(_guard, name, params, false);
        return fragment.topicHash;
    }
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
    static from(obj) {
        if (EventFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return EventFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid event fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new EventFragment(_guard, name, inputs, anonymous);
        }
        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === EventFragmentInternal);
    }
}
/**
 *  A Fragment which represents a constructor.
 */
class ConstructorFragment extends Fragment {
    /**
     *  Whether the constructor can receive an endowment.
     */
    payable;
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    gas;
    /**
     *  @private
     */
    constructor(guard, type, inputs, payable, gas) {
        super(guard, type, inputs);
        Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
        defineProperties(this, { payable, gas });
    }
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    format(format) {
        assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
        if (format === "json") {
            return JSON.stringify({
                type: "constructor",
                stateMutability: (this.payable ? "payable" : "undefined"),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [`constructor${joinParams(format, this.inputs)}`];
        if (this.payable) {
            result.push("payable");
        }
        if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
    }
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ConstructorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ConstructorFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid constuctor fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === ConstructorFragmentInternal);
    }
}
/**
 *  A Fragment which represents a method.
 */
class FallbackFragment extends Fragment {
    /**
     *  If the function can be sent value during invocation.
     */
    payable;
    constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
        defineProperties(this, { payable });
    }
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    format(format) {
        const type = ((this.inputs.length === 0) ? "receive" : "fallback");
        if (format === "json") {
            const stateMutability = (this.payable ? "payable" : "nonpayable");
            return JSON.stringify({ type, stateMutability });
        }
        return `${type}()${this.payable ? " payable" : ""}`;
    }
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
    static from(obj) {
        if (FallbackFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FallbackFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid fallback fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            // receive()
            if (type === "receive") {
                const inputs = consumeParams(obj);
                assertArgument(inputs.length === 0, `receive cannot have arguments`, "obj.inputs", inputs);
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard, [], true);
            }
            // fallback() [payable]
            // fallback(bytes) [payable] returns (bytes)
            let inputs = consumeParams(obj);
            if (inputs.length) {
                assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
            }
            else {
                inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
            return new FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = (obj.stateMutability === "payable");
            return new FallbackFragment(_guard, inputs, payable);
        }
        assertArgument(false, "invalid fallback description", "obj", obj);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === FallbackFragmentInternal);
    }
}
/**
 *  A Fragment which represents a method.
 */
class FunctionFragment extends NamedFragment {
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    constant;
    /**
     *  The returned types for the result of calling this function.
     */
    outputs;
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    stateMutability;
    /**
     *  If the function can be sent value during invocation.
     */
    payable;
    /**
     *  The recommended gas limit to send when calling this function.
     */
    gas;
    /**
     *  @private
     */
    constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = (stateMutability === "view" || stateMutability === "pure");
        const payable = (stateMutability === "payable");
        defineProperties(this, { constant, gas, outputs, payable, stateMutability });
    }
    /**
     *  The Function selector.
     */
    get selector() {
        return id(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this function as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("function");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
            }
        }
        return result.join(" ");
    }
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
    static getSelector(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
    }
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
    static from(obj) {
        if (FunctionFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FunctionFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid function fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        // Use legacy Solidity ABI logic if stateMutability is missing
        if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof (obj.constant) === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                    stateMutability = "payable";
                    if (typeof (obj.payable) === "boolean" && !obj.payable) {
                        stateMutability = "nonpayable";
                    }
                }
            }
            else if (typeof (obj.payable) === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
            }
        }
        // @TODO: verifyState for stateMutability (e.g. throw if
        //        payable: false but stateMutability is "nonpayable")
        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === FunctionFragmentInternal);
    }
}
/**
 *  A Fragment which represents a structure.
 */
class StructFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
    }
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    format() {
        throw new Error("@TODO");
    }
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            try {
                return StructFragment.from(lex(obj));
            }
            catch (error) {
                assertArgument(false, "invalid struct fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new StructFragment(_guard, name, inputs);
        }
        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    // @TODO: fix this return type
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
    static isFragment(value) {
        return (value && value[internal$1] === StructFragmentInternal);
    }
}

/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](link-solc-abi).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
const PanicReasons$1 = new Map();
PanicReasons$1.set(0x00, "GENERIC_PANIC");
PanicReasons$1.set(0x01, "ASSERT_FALSE");
PanicReasons$1.set(0x11, "OVERFLOW");
PanicReasons$1.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons$1.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons$1.set(0x22, "BAD_STORAGE_DATA");
PanicReasons$1.set(0x31, "STACK_UNDERFLOW");
PanicReasons$1.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(0x41, "OUT_OF_MEMORY");
PanicReasons$1.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
    let message = "missing revert data";
    let reason = null;
    const invocation = null;
    let revert = null;
    if (data) {
        message = "execution reverted";
        const bytes = getBytes(data);
        data = hexlify(data);
        if (bytes.length === 0) {
            message += " (no data present; likely require(false) occurred";
            reason = "require(false)";
        }
        else if (bytes.length % 32 !== 4) {
            message += " (could not decode reason; invalid data length)";
        }
        else if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
            // Error(string)
            try {
                reason = abiCoder.decode(["string"], bytes.slice(4))[0];
                revert = {
                    signature: "Error(string)",
                    name: "Error",
                    args: [reason]
                };
                message += `: ${JSON.stringify(reason)}`;
            }
            catch (error) {
                message += " (could not decode reason; invalid string data)";
            }
        }
        else if (hexlify(bytes.slice(0, 4)) === "0x4e487b71") {
            // Panic(uint256)
            try {
                const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
                revert = {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    args: [code]
                };
                reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
                message += `: ${reason}`;
            }
            catch (error) {
                message += " (could not decode panic code)";
            }
        }
        else {
            message += " (unknown custom error)";
        }
    }
    const transaction = {
        to: (tx.to ? getAddress(tx.to) : null),
        data: (tx.data || "0x")
    };
    if (tx.from) {
        transaction.from = getAddress(tx.from);
    }
    return makeError(message, "CALL_EXCEPTION", {
        action, data, reason, transaction, invocation, revert
    });
}
/**
 *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
 *  values into binary data and decoding binary data into JavaScript values.
 */
class AbiCoder {
    #getCoder(param) {
        if (param.isArray()) {
            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
        }
        if (param.isTuple()) {
            return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
        }
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, "invalid " + match[1] + " bit length", "param", param);
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
            return new FixedBytesCoder(size, param.name);
        }
        assertArgument(false, "invalid type", "type", param.type);
    }
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    getDefaultValue(types) {
        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encode(types, values) {
        assertArgumentCount(values.length, types.length, "types/values length mismatch");
        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = new Writer();
        coder.encode(writer, values);
        return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
    decode(types, data, loose) {
        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(new Reader(data, loose, defaultMaxInflation));
    }
    static _setDefaultMaxInflation(value) {
        assertArgument(typeof (value) === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
        defaultMaxInflation = value;
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
    static defaultAbiCoder() {
        if (defaultCoder == null) {
            defaultCoder = new AbiCoder();
        }
        return defaultCoder;
    }
    /**
     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
     *  result %%data%% for the [[CallExceptionAction]] %%action%% against
     *  the Transaction %%tx%%.
     */
    static getBuiltinCallException(action, tx, data) {
        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
    }
}

/**
 *  The Interface class is a low-level class that accepts an
 *  ABI and provides all the necessary functionality to encode
 *  and decode paramaters to and results from methods, events
 *  and errors.
 *
 *  It also provides several convenience methods to automatically
 *  search and find matching transactions and events to parse them.
 *
 *  @_subsection api/abi:Interfaces  [interfaces]
 */
/**
 *  When using the [[Interface-parseLog]] to automatically match a Log to its event
 *  for parsing, a **LogDescription** is returned.
 */
class LogDescription {
    /**
     *  The matching fragment for the ``topic0``.
     */
    fragment;
    /**
     *  The name of the Event.
     */
    name;
    /**
     *  The full Event signature.
     */
    signature;
    /**
     *  The topic hash for the Event.
     */
    topic;
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    args;
    /**
     *  @_ignore:
     */
    constructor(fragment, topic, args) {
        const name = fragment.name, signature = fragment.format();
        defineProperties(this, {
            fragment, name, signature, topic, args
        });
    }
}
/**
 *  When using the [[Interface-parseTransaction]] to automatically match
 *  a transaction data to its function for parsing,
 *  a **TransactionDescription** is returned.
 */
class TransactionDescription {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    fragment;
    /**
     *  The name of the Function from the transaction ``data``.
     */
    name;
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    args;
    /**
     *  The full Function signature from the transaction ``data``.
     */
    signature;
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    selector;
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    value;
    /**
     *  @_ignore:
     */
    constructor(fragment, selector, args, value) {
        const name = fragment.name, signature = fragment.format();
        defineProperties(this, {
            fragment, name, args, signature, selector, value
        });
    }
}
/**
 *  When using the [[Interface-parseError]] to automatically match an
 *  error for a call result for parsing, an **ErrorDescription** is returned.
 */
class ErrorDescription {
    /**
     *  The matching fragment.
     */
    fragment;
    /**
     *  The name of the Error.
     */
    name;
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    args;
    /**
     *  The full Error signature.
     */
    signature;
    /**
     *  The selector for the Error.
     */
    selector;
    /**
     *  @_ignore:
     */
    constructor(fragment, selector, args) {
        const name = fragment.name, signature = fragment.format();
        defineProperties(this, {
            fragment, name, args, signature, selector
        });
    }
}
/**
 *  An **Indexed** is used as a value when a value that does not
 *  fit within a topic (i.e. not a fixed-length, 32-byte type). It
 *  is the ``keccak256`` of the value, and used for types such as
 *  arrays, tuples, bytes and strings.
 */
class Indexed {
    /**
     *  The ``keccak256`` of the value logged.
     */
    hash;
    /**
     *  @_ignore:
     */
    _isIndexed;
    /**
     *  Returns ``true`` if %%value%% is an **Indexed**.
     *
     *  This provides a Type Guard for property access.
     */
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
    /**
     *  @_ignore:
     */
    constructor(hash) {
        defineProperties(this, { hash, _isIndexed: true });
    }
}
// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
const PanicReasons = {
    "0": "generic panic",
    "1": "assert(false)",
    "17": "arithmetic overflow",
    "18": "division or modulo by zero",
    "33": "enum overflow",
    "34": "invalid encoded storage byte array accessed",
    "49": "out-of-bounds array access; popping on an empty array",
    "50": "out-of-bounds access of an array or bytesN",
    "65": "out of memory",
    "81": "uninitialized function",
};
const BuiltinErrors = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: (message) => {
            return `reverted with reason string ${JSON.stringify(message)}`;
        }
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: (code) => {
            let reason = "unknown panic code";
            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
                reason = PanicReasons[code.toString()];
            }
            return `reverted with panic code 0x${code.toString(16)} (${reason})`;
        }
    }
};
/**
 *  An Interface abstracts many of the low-level details for
 *  encoding and decoding the data on the blockchain.
 *
 *  An ABI provides information on how to encode data to send to
 *  a Contract, how to decode the results and events and how to
 *  interpret revert errors.
 *
 *  The ABI can be specified by [any supported format](InterfaceAbi).
 */
class Interface {
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    fragments;
    /**
     *  The Contract constructor.
     */
    deploy;
    /**
     *  The Fallback method, if any.
     */
    fallback;
    /**
     *  If receiving ether is supported.
     */
    receive;
    #errors;
    #events;
    #functions;
    //    #structs: Map<string, StructFragment>;
    #abiCoder;
    /**
     *  Create a new Interface for the %%fragments%%.
     */
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        this.#functions = new Map();
        this.#errors = new Map();
        this.#events = new Map();
        //        this.#structs = new Map();
        const frags = [];
        for (const a of abi) {
            try {
                frags.push(Fragment.from(a));
            }
            catch (error) {
                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
            }
        }
        defineProperties(this, {
            fragments: Object.freeze(frags)
        });
        let fallback = null;
        let receive = false;
        this.#abiCoder = this.getAbiCoder();
        // Add all fragments by their signature
        this.fragments.forEach((fragment, index) => {
            let bucket;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        console.log("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineProperties(this, { deploy: fragment });
                    return;
                case "fallback":
                    if (fragment.inputs.length === 0) {
                        receive = true;
                    }
                    else {
                        assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
                        fallback = fragment;
                        receive = fallback.payable;
                    }
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.#functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.#events;
                    break;
                case "error":
                    bucket = this.#errors;
                    break;
                default:
                    return;
            }
            // Two identical entries; ignore it
            const signature = fragment.format();
            if (bucket.has(signature)) {
                return;
            }
            bucket.set(signature, fragment);
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineProperties(this, {
                deploy: ConstructorFragment.from("constructor()")
            });
        }
        defineProperties(this, { fallback, receive });
    }
    /**
     *  Returns the entire Human-Readable ABI, as an array of
     *  signatures, optionally as %%minimal%% strings, which
     *  removes parameter names and unneceesary spaces.
     */
    format(minimal) {
        const format = (minimal ? "minimal" : "full");
        const abi = this.fragments.map((f) => f.format(format));
        return abi;
    }
    /**
     *  Return the JSON-encoded ABI. This is the format Solidiy
     *  returns.
     */
    formatJson() {
        const abi = this.fragments.map((f) => f.format("json"));
        // We need to re-bundle the JSON fragments a bit
        return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    /**
     *  The ABI coder that will be used to encode and decode binary
     *  data.
     */
    getAbiCoder() {
        return AbiCoder.defaultAbiCoder();
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    #getFunction(key, values, forceUnique) {
        // Selector
        if (isHexString(key)) {
            const selector = key.toLowerCase();
            for (const fragment of this.#functions.values()) {
                if (selector === fragment.selector) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#functions) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (values) {
                const lastValue = (values.length > 0) ? values[values.length - 1] : null;
                let valueLength = values.length;
                let allowOptions = true;
                if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
                    allowOptions = false;
                    valueLength--;
                }
                // Remove all matches that don't have a compatible length. The args
                // may contain an overrides, so the match may have n or n - 1 parameters
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs.length;
                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
                        matching.splice(i, 1);
                    }
                }
                // Remove all matches that don't match the Typed signature
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs;
                    for (let j = 0; j < values.length; j++) {
                        // Not a typed value
                        if (!Typed.isTyped(values[j])) {
                            continue;
                        }
                        // We are past the inputs
                        if (j >= inputs.length) {
                            if (values[j].type === "overrides") {
                                continue;
                            }
                            matching.splice(i, 1);
                            break;
                        }
                        // Make sure the value type matches the input type
                        if (values[j].type !== inputs[j].baseType) {
                            matching.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            // We found a single matching signature with an overrides, but the
            // last value is something that cannot possibly be an options
            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
                const lastArg = values[values.length - 1];
                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== "object") {
                    matching.splice(0, 1);
                }
            }
            if (matching.length === 0) {
                return null;
            }
            if (matching.length > 1 && forceUnique) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        const result = this.#functions.get(FunctionFragment.from(key).format());
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Get the function name for %%key%%, which may be a function selector,
     *  function name or function signature that belongs to the ABI.
     */
    getFunctionName(key) {
        const fragment = this.#getFunction(key, null, false);
        assertArgument(fragment, "no matching function", "key", key);
        return fragment.name;
    }
    /**
     *  Returns true if %%key%% (a function selector, function name or
     *  function signature) is present in the ABI.
     *
     *  In the case of a function name, the name may be ambiguous, so
     *  accessing the [[FunctionFragment]] may require refinement.
     */
    hasFunction(key) {
        return !!this.#getFunction(key, null, false);
    }
    /**
     *  Get the [[FunctionFragment]] for %%key%%, which may be a function
     *  selector, function name or function signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple functions match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single function in
     *  the ABI, this will throw.
     */
    getFunction(key, values) {
        return this.#getFunction(key, values || null, true);
    }
    /**
     *  Iterate over all functions, calling %%callback%%, sorted by their name.
     */
    forEachFunction(callback) {
        const names = Array.from(this.#functions.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#functions.get(name)), i);
        }
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    #getEvent(key, values, forceUnique) {
        // EventTopic
        if (isHexString(key)) {
            const eventTopic = key.toLowerCase();
            for (const fragment of this.#events.values()) {
                if (eventTopic === fragment.topicHash) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#events) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (values) {
                // Remove all matches that don't have a compatible length.
                for (let i = matching.length - 1; i >= 0; i--) {
                    if (matching[i].inputs.length < values.length) {
                        matching.splice(i, 1);
                    }
                }
                // Remove all matches that don't match the Typed signature
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs;
                    for (let j = 0; j < values.length; j++) {
                        // Not a typed value
                        if (!Typed.isTyped(values[j])) {
                            continue;
                        }
                        // Make sure the value type matches the input type
                        if (values[j].type !== inputs[j].baseType) {
                            matching.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            if (matching.length === 0) {
                return null;
            }
            if (matching.length > 1 && forceUnique) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        const result = this.#events.get(EventFragment.from(key).format());
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Get the event name for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     */
    getEventName(key) {
        const fragment = this.#getEvent(key, null, false);
        assertArgument(fragment, "no matching event", "key", key);
        return fragment.name;
    }
    /**
     *  Returns true if %%key%% (an event topic hash, event name or
     *  event signature) is present in the ABI.
     *
     *  In the case of an event name, the name may be ambiguous, so
     *  accessing the [[EventFragment]] may require refinement.
     */
    hasEvent(key) {
        return !!this.#getEvent(key, null, false);
    }
    /**
     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple events match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single event in
     *  the ABI, this will throw.
     */
    getEvent(key, values) {
        return this.#getEvent(key, values || null, true);
    }
    /**
     *  Iterate over all events, calling %%callback%%, sorted by their name.
     */
    forEachEvent(callback) {
        const names = Array.from(this.#events.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#events.get(name)), i);
        }
    }
    /**
     *  Get the [[ErrorFragment]] for %%key%%, which may be an error
     *  selector, error name or error signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple errors match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single error in
     *  the ABI, this will throw.
     */
    getError(key, values) {
        if (isHexString(key)) {
            const selector = key.toLowerCase();
            if (BuiltinErrors[selector]) {
                return ErrorFragment.from(BuiltinErrors[selector].signature);
            }
            for (const fragment of this.#errors.values()) {
                if (selector === fragment.selector) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#errors) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (matching.length === 0) {
                if (key === "Error") {
                    return ErrorFragment.from("error Error(string)");
                }
                if (key === "Panic") {
                    return ErrorFragment.from("error Panic(uint256)");
                }
                return null;
            }
            else if (matching.length > 1) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        key = ErrorFragment.from(key).format();
        if (key === "Error(string)") {
            return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic(uint256)") {
            return ErrorFragment.from("error Panic(uint256)");
        }
        const result = this.#errors.get(key);
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Iterate over all errors, calling %%callback%%, sorted by their name.
     */
    forEachError(callback) {
        const names = Array.from(this.#errors.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#errors.get(name)), i);
        }
    }
    // Get the 4-byte selector used by Solidity to identify a function
    /*
getSelector(fragment: ErrorFragment | FunctionFragment): string {
    if (typeof(fragment) === "string") {
        const matches: Array<Fragment> = [ ];

        try { matches.push(this.getFunction(fragment)); } catch (error) { }
        try { matches.push(this.getError(<string>fragment)); } catch (_) { }

        if (matches.length === 0) {
            logger.throwArgumentError("unknown fragment", "key", fragment);
        } else if (matches.length > 1) {
            logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
        }

        fragment = matches[0];
    }

    return dataSlice(id(fragment.format()), 0, 4);
}
    */
    // Get the 32-byte topic hash used by Solidity to identify an event
    /*
    getEventTopic(fragment: EventFragment): string {
        //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
        return id(fragment.format());
    }
    */
    _decodeParams(params, data) {
        return this.#abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this.#abiCoder.encode(params, values);
    }
    /**
     *  Encodes a ``tx.data`` object for deploying the Contract with
     *  the %%values%% as the constructor arguments.
     */
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified error (see [[getError]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getError(fragment);
            assertArgument(f, "unknown error", "fragment", fragment);
            fragment = f;
        }
        assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    /**
     *  Encodes the transaction revert data for a call result that
     *  reverted from the the Contract with the sepcified %%error%%
     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getError(fragment);
            assertArgument(f, "unknown error", "fragment", fragment);
            fragment = f;
        }
        return concat([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
        ]);
    }
    /**
     *  Decodes the %%data%% from a transaction ``tx.data`` for
     *  the function specified (see [[getFunction]] for valid values
     *  for %%fragment%%).
     *
     *  Most developers should prefer the [[parseTransaction]] method
     *  instead, which will automatically detect the fragment.
     */
    decodeFunctionData(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    /**
     *  Encodes the ``tx.data`` for a transaction that calls the function
     *  specified (see [[getFunction]] for valid values for %%fragment%%) with
     *  the %%values%%.
     */
    encodeFunctionData(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        return concat([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
        ]);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeFunctionResult(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        let message = "invalid length for result data";
        const bytes = getBytesCopy(data);
        if ((bytes.length % 32) === 0) {
            try {
                return this.#abiCoder.decode(fragment.outputs, bytes);
            }
            catch (error) {
                message = "could not decode result data";
            }
        }
        // Call returned data with no error, but the data is junk
        assert(false, message, "BAD_DATA", {
            value: hexlify(bytes),
            info: { method: fragment.name, signature: fragment.format() }
        });
    }
    makeError(_data, tx) {
        const data = getBytes(_data, "data");
        const error = AbiCoder.getBuiltinCallException("call", tx, data);
        // Not a built-in error; try finding a custom error
        const customPrefix = "execution reverted (unknown custom error)";
        if (error.message.startsWith(customPrefix)) {
            const selector = hexlify(data.slice(0, 4));
            const ef = this.getError(selector);
            if (ef) {
                try {
                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                    error.revert = {
                        name: ef.name, signature: ef.format(), args
                    };
                    error.reason = error.revert.signature;
                    error.message = `execution reverted: ${error.reason}`;
                }
                catch (e) {
                    error.message = `execution reverted (coult not decode custom error)`;
                }
            }
        }
        // Add the invocation, if available
        const parsed = this.parseTransaction(tx);
        if (parsed) {
            error.invocation = {
                method: parsed.name,
                signature: parsed.signature,
                args: parsed.args
            };
        }
        return error;
    }
    /**
     *  Encodes the result data (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values
     *  for %%fragment%%) with %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeFunctionResult(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            assertArgument(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
    }
    /*
        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
            const promises: Array<Promise<>> = [ ];
            const process = function(type: ParamType, value: any): any {
                if (type.baseType === "array") {
                    return descend(type.child
                }
                if (type. === "address") {
                }
            };
    
            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                
            };
    
            const result: Array<any> = [ ];
            values.forEach((value, index) => {
                if (value == null) {
                    topics.push(null);
                } else if (param.baseType === "array" || param.baseType === "tuple") {
                    logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                } else if (Array.isArray(value)) {
                    topics.push(value.map((value) => encodeTopic(param, value)));
                } else {
                    topics.push(encodeTopic(param, value));
                }
            });
        }
    */
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            assertArgument(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
        const topics = [];
        if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
        }
        // @TODO: Use the coders for this; to properly support tuples, etc.
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            else if (param.type.match(/^u?int/)) {
                value = toBeHex(value); // @TODO: Should this toTwos??
            }
            else if (param.type.match(/^bytes/)) {
                value = zeroPadBytes(value, 32);
            }
            else if (param.type === "address") {
                // Check addresses are valid
                this.#abiCoder.encode(["address"], [value]);
            }
            return zeroPadValue(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            const param = fragment.inputs[index];
            if (!param.indexed) {
                assertArgument(value == null, "cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                assertArgument(false, "filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            assertArgument(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
        }
        assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
        fragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this.#abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this.#abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(fragment, data, topics) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            assertArgument(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        if (topics != null && !fragment.anonymous) {
            const eventTopic = fragment.topicHash;
            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
            topics = topics.slice(1);
        }
        const indexed = [];
        const nonIndexed = [];
        const dynamic = [];
        fragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)) : null;
        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
        //const result: (Array<any> & { [ key: string ]: any }) = [ ];
        const values = [];
        const keys = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        fragment.inputs.forEach((param, index) => {
            let value = null;
            if (param.indexed) {
                if (resultIndexed == null) {
                    value = new Indexed(null);
                }
                else if (dynamic[index]) {
                    value = new Indexed(resultIndexed[indexedIndex++]);
                }
                else {
                    try {
                        value = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        value = error;
                    }
                }
            }
            else {
                try {
                    value = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    value = error;
                }
            }
            values.push(value);
            keys.push(param.name || null);
        });
        return Result.fromItems(values, keys);
    }
    /**
     *  Parses a transaction, finding the matching function and extracts
     *  the parameter values along with other useful function details.
     *
     *  If the matching function cannot be found, return null.
     */
    parseTransaction(tx) {
        const data = getBytes(tx.data, "tx.data");
        const value = getBigInt((tx.value != null) ? tx.value : 0, "tx.value");
        const fragment = this.getFunction(hexlify(data.slice(0, 4)));
        if (!fragment) {
            return null;
        }
        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
        return new TransactionDescription(fragment, fragment.selector, args, value);
    }
    parseCallResult(data) {
        throw new Error("@TODO");
    }
    /**
     *  Parses a receipt log, finding the matching event and extracts
     *  the parameter values along with other useful event details.
     *
     *  If the matching event cannot be found, returns null.
     */
    parseLog(log) {
        const fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
    }
    /**
     *  Parses a revert data, finding the matching error and extracts
     *  the parameter values along with other useful error details.
     *
     *  If the matching error cannot be found, returns null.
     */
    parseError(data) {
        const hexData = hexlify(data);
        const fragment = this.getError(dataSlice(hexData, 0, 4));
        if (!fragment) {
            return null;
        }
        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
        return new ErrorDescription(fragment, fragment.selector, args);
    }
    /**
     *  Creates a new [[Interface]] from the ABI %%value%%.
     *
     *  The %%value%% may be provided as an existing [[Interface]] object,
     *  a JSON-encoded ABI or any Human-Readable ABI format.
     */
    static from(value) {
        // Already an Interface, which is immutable
        if (value instanceof Interface) {
            return value;
        }
        // JSON
        if (typeof (value) === "string") {
            return new Interface(JSON.parse(value));
        }
        // An Interface; possibly from another v6 instance
        if (typeof (value.formatJson) === "function") {
            return new Interface(value.formatJson());
        }
        // A legacy Interface; from an older version
        if (typeof (value.format) === "function") {
            return new Interface(value.format("json"));
        }
        // Array of fragments
        return new Interface(value);
    }
}

//import { resolveAddress } from "@ethersproject/address";
const BN_0$1 = BigInt(0);
function toJson(value) {
    if (value == null) {
        return null;
    }
    return value.toString();
}
/**
 *  Returns a copy of %%req%% with all properties coerced to their strict
 *  types.
 */
function copyRequest(req) {
    const result = {};
    // These could be addresses, ENS names or Addressables
    if (req.to) {
        result.to = req.to;
    }
    if (req.from) {
        result.from = req.from;
    }
    if (req.data) {
        result.data = hexlify(req.data);
    }
    const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const key of bigIntKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = getBigInt(req[key], `request.${key}`);
    }
    const numberKeys = "type,nonce".split(/,/);
    for (const key of numberKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = getNumber(req[key], `request.${key}`);
    }
    if (req.accessList) {
        result.accessList = accessListify(req.accessList);
    }
    if (req.authorizationList) {
        result.authorizationList = req.authorizationList.slice();
    }
    if ("blockTag" in req) {
        result.blockTag = req.blockTag;
    }
    if ("enableCcipRead" in req) {
        result.enableCcipRead = !!req.enableCcipRead;
    }
    if ("customData" in req) {
        result.customData = req.customData;
    }
    if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
        result.blobVersionedHashes = req.blobVersionedHashes.slice();
    }
    if ("kzg" in req) {
        result.kzg = req.kzg;
    }
    if ("blobs" in req && req.blobs) {
        result.blobs = req.blobs.map((b) => {
            if (isBytesLike(b)) {
                return hexlify(b);
            }
            return Object.assign({}, b);
        });
    }
    return result;
}
//////////////////////
// Log
/**
 *  A **Log** in Ethereum represents an event that has been included in a
 *  transaction using the ``LOG*`` opcodes, which are most commonly used by
 *  Solidity's emit for announcing events.
 */
class Log {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    transactionHash;
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    blockHash;
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    blockNumber;
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    removed;
    /**
     *  The address of the contract that emitted this log.
     */
    address;
    /**
     *  The data included in this log when it was emitted.
     */
    data;
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    topics;
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    index;
    /**
     *  The index within the transaction of this log.
     */
    transactionIndex;
    /**
     *  @_ignore:
     */
    constructor(log, provider) {
        this.provider = provider;
        const topics = Object.freeze(log.topics.slice());
        defineProperties(this, {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            removed: log.removed,
            address: log.address,
            data: log.data,
            topics,
            index: log.index,
            transactionIndex: log.transactionIndex,
        });
    }
    /**
     *  Returns a JSON-compatible object.
     */
    toJSON() {
        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
        return {
            _type: "log",
            address, blockHash, blockNumber, data, index,
            removed, topics, transactionHash, transactionIndex
        };
    }
    /**
     *  Returns the block that this log occurred in.
     */
    async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
        return block;
    }
    /**
     *  Returns the transaction that this log occurred in.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.transactionHash);
        assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
        return tx;
    }
    /**
     *  Returns the transaction receipt fot the transaction that this
     *  log occurred in.
     */
    async getTransactionReceipt() {
        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
        assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
        return receipt;
    }
    /**
     *  @_ignore:
     */
    removedEvent() {
        return createRemovedLogFilter(this);
    }
}
//////////////////////
// Transaction Receipt
/*
export interface LegacyTransactionReceipt {
    byzantium: false;
    status: null;
    root: string;
}

export interface ByzantiumTransactionReceipt {
    byzantium: true;
    status: number;
    root: null;
}
*/
/**
 *  A **TransactionReceipt** includes additional information about a
 *  transaction that is only available after it has been mined.
 */
class TransactionReceipt {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The address the transaction was sent to.
     */
    to;
    /**
     *  The sender of the transaction.
     */
    from;
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    contractAddress;
    /**
     *  The transaction hash.
     */
    hash;
    /**
     *  The index of this transaction within the block transactions.
     */
    index;
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    blockHash;
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    blockNumber;
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    logsBloom;
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    gasUsed;
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    blobGasUsed;
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    cumulativeGasUsed;
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    gasPrice;
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    blobGasPrice;
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    type;
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    status;
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    root;
    #logs;
    /**
     *  @_ignore:
     */
    constructor(tx, provider) {
        this.#logs = Object.freeze(tx.logs.map((log) => {
            return new Log(log, provider);
        }));
        let gasPrice = BN_0$1;
        if (tx.effectiveGasPrice != null) {
            gasPrice = tx.effectiveGasPrice;
        }
        else if (tx.gasPrice != null) {
            gasPrice = tx.gasPrice;
        }
        defineProperties(this, {
            provider,
            to: tx.to,
            from: tx.from,
            contractAddress: tx.contractAddress,
            hash: tx.hash,
            index: tx.index,
            blockHash: tx.blockHash,
            blockNumber: tx.blockNumber,
            logsBloom: tx.logsBloom,
            gasUsed: tx.gasUsed,
            cumulativeGasUsed: tx.cumulativeGasUsed,
            blobGasUsed: tx.blobGasUsed,
            gasPrice,
            blobGasPrice: tx.blobGasPrice,
            type: tx.type,
            //byzantium: tx.byzantium,
            status: tx.status,
            root: tx.root
        });
    }
    /**
     *  The logs for this transaction.
     */
    get logs() { return this.#logs; }
    /**
     *  Returns a JSON-compatible representation.
     */
    toJSON() {
        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, 
        status, root } = this;
        return {
            _type: "TransactionReceipt",
            blockHash, blockNumber,
            //byzantium, 
            contractAddress,
            cumulativeGasUsed: toJson(this.cumulativeGasUsed),
            from,
            gasPrice: toJson(this.gasPrice),
            blobGasUsed: toJson(this.blobGasUsed),
            blobGasPrice: toJson(this.blobGasPrice),
            gasUsed: toJson(this.gasUsed),
            hash, index, logs, logsBloom, root, status, to
        };
    }
    /**
     *  @_ignore:
     */
    get length() { return this.logs.length; }
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => {
                if (index < this.length) {
                    return { value: this.logs[index++], done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The total fee for this transaction, in wei.
     */
    get fee() {
        return this.gasUsed * this.gasPrice;
    }
    /**
     *  Resolves to the block this transaction occurred in.
     */
    async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        if (block == null) {
            throw new Error("TODO");
        }
        return block;
    }
    /**
     *  Resolves to the transaction this transaction occurred in.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.hash);
        if (tx == null) {
            throw new Error("TODO");
        }
        return tx;
    }
    /**
     *  Resolves to the return value of the execution of this transaction.
     *
     *  Support for this feature is limited, as it requires an archive node
     *  with the ``debug_`` or ``trace_`` API enabled.
     */
    async getResult() {
        return (await this.provider.getTransactionResult(this.hash));
    }
    /**
     *  Resolves to the number of confirmations this transaction has.
     */
    async confirmations() {
        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
    }
    /**
     *  @_ignore:
     */
    removedEvent() {
        return createRemovedTransactionFilter(this);
    }
    /**
     *  @_ignore:
     */
    reorderedEvent(other) {
        assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
        return createReorderedTransactionFilter(this, other);
    }
}
/**
 *  A **TransactionResponse** includes all properties about a transaction
 *  that was sent to the network, which may or may not be included in a
 *  block.
 *
 *  The [[TransactionResponse-isMined]] can be used to check if the
 *  transaction has been mined as well as type guard that the otherwise
 *  possibly ``null`` properties are defined.
 */
class TransactionResponse {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    provider;
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    blockNumber;
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    blockHash;
    /**
     *  The index within the block that this transaction resides at.
     */
    index;
    /**
     *  The transaction hash.
     */
    hash;
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    type;
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    to;
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    from;
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    nonce;
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    gasLimit;
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    gasPrice;
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    maxPriorityFeePerGas;
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    maxFeePerGas;
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    maxFeePerBlobGas;
    /**
     *  The data.
     */
    data;
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    value;
    /**
     *  The chain ID.
     */
    chainId;
    /**
     *  The signature.
     */
    signature;
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    accessList;
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    blobVersionedHashes;
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    authorizationList;
    #startBlock;
    /**
     *  @_ignore:
     */
    constructor(tx, provider) {
        this.provider = provider;
        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;
        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.gasPrice = tx.gasPrice;
        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;
        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;
        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = (tx.accessList != null) ? tx.accessList : null;
        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;
        this.authorizationList = (tx.authorizationList != null) ? tx.authorizationList : null;
        this.#startBlock = -1;
    }
    /**
     *  Returns a JSON-compatible representation of this transaction.
     */
    toJSON() {
        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
        return {
            _type: "TransactionResponse",
            accessList, blockNumber, blockHash,
            blobVersionedHashes,
            chainId: toJson(this.chainId),
            data, from,
            gasLimit: toJson(this.gasLimit),
            gasPrice: toJson(this.gasPrice),
            hash,
            maxFeePerGas: toJson(this.maxFeePerGas),
            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
            nonce, signature, to, index, type,
            value: toJson(this.value),
        };
    }
    /**
     *  Resolves to the Block that this transaction was included in.
     *
     *  This will return null if the transaction has not been included yet.
     */
    async getBlock() {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
                blockNumber = tx.blockNumber;
            }
        }
        if (blockNumber == null) {
            return null;
        }
        const block = this.provider.getBlock(blockNumber);
        if (block == null) {
            throw new Error("TODO");
        }
        return block;
    }
    /**
     *  Resolves to this transaction being re-requested from the
     *  provider. This can be used if you have an unmined transaction
     *  and wish to get an up-to-date populated instance.
     */
    async getTransaction() {
        return this.provider.getTransaction(this.hash);
    }
    /**
     *  Resolve to the number of confirmations this transaction has.
     */
    async confirmations() {
        if (this.blockNumber == null) {
            const { tx, blockNumber } = await resolveProperties({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
            });
            // Not mined yet...
            if (tx == null || tx.blockNumber == null) {
                return 0;
            }
            return blockNumber - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber();
        return blockNumber - this.blockNumber + 1;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    async wait(_confirms, _timeout) {
        const confirms = (_confirms == null) ? 1 : _confirms;
        const timeout = (_timeout == null) ? 0 : _timeout;
        let startBlock = this.#startBlock;
        let nextScan = -1;
        let stopScanning = (startBlock === -1) ? true : false;
        const checkReplacement = async () => {
            // Get the current transaction count for this sender
            if (stopScanning) {
                return null;
            }
            const { blockNumber, nonce } = await resolveProperties({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from)
            });
            // No transaction or our nonce has not been mined yet; but we
            // can start scanning later when we do start
            if (nonce < this.nonce) {
                startBlock = blockNumber;
                return;
            }
            // We were mined; no replacement
            if (stopScanning) {
                return null;
            }
            const mined = await this.getTransaction();
            if (mined && mined.blockNumber != null) {
                return;
            }
            // We were replaced; start scanning for that transaction
            // Starting to scan; look back a few extra blocks for safety
            if (nextScan === -1) {
                nextScan = startBlock - 3;
                if (nextScan < this.#startBlock) {
                    nextScan = this.#startBlock;
                }
            }
            while (nextScan <= blockNumber) {
                // Get the next block to scan
                if (stopScanning) {
                    return null;
                }
                const block = await this.provider.getBlock(nextScan, true);
                // This should not happen; but we'll try again shortly
                if (block == null) {
                    return;
                }
                // We were mined; no replacement
                for (const hash of block) {
                    if (hash === this.hash) {
                        return;
                    }
                }
                // Search for the transaction that replaced us
                for (let i = 0; i < block.length; i++) {
                    const tx = await block.getTransaction(i);
                    if (tx.from === this.from && tx.nonce === this.nonce) {
                        // Get the receipt
                        if (stopScanning) {
                            return null;
                        }
                        const receipt = await this.provider.getTransactionReceipt(tx.hash);
                        // This should not happen; but we'll try again shortly
                        if (receipt == null) {
                            return;
                        }
                        // We will retry this on the next block (this case could be optimized)
                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {
                            return;
                        }
                        // The reason we were replaced
                        let reason = "replaced";
                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                            reason = "repriced";
                        }
                        else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$1) {
                            reason = "cancelled";
                        }
                        assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                            cancelled: (reason === "replaced" || reason === "cancelled"),
                            reason,
                            replacement: tx.replaceableTransaction(startBlock),
                            hash: tx.hash,
                            receipt
                        });
                    }
                }
                nextScan++;
            }
            return;
        };
        const checkReceipt = (receipt) => {
            if (receipt == null || receipt.status !== 0) {
                return receipt;
            }
            assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
                action: "sendTransaction",
                data: null, reason: null, invocation: null, revert: null,
                transaction: {
                    to: receipt.to,
                    from: receipt.from,
                    data: "" // @TODO: in v7, split out sendTransaction properties
                }, receipt
            });
        };
        const receipt = await this.provider.getTransactionReceipt(this.hash);
        if (confirms === 0) {
            return checkReceipt(receipt);
        }
        if (receipt) {
            if (confirms === 1 || (await receipt.confirmations()) >= confirms) {
                return checkReceipt(receipt);
            }
        }
        else {
            // Check for a replacement; throws if a replacement was found
            await checkReplacement();
            // Allow null only when the confirms is 0
            if (confirms === 0) {
                return null;
            }
        }
        const waiter = new Promise((resolve, reject) => {
            // List of things to cancel when we have a result (one way or the other)
            const cancellers = [];
            const cancel = () => { cancellers.forEach((c) => c()); };
            // On cancel, stop scanning for replacements
            cancellers.push(() => { stopScanning = true; });
            // Set up any timeout requested
            if (timeout > 0) {
                const timer = setTimeout(() => {
                    cancel();
                    reject(makeError("wait for transaction timeout", "TIMEOUT"));
                }, timeout);
                cancellers.push(() => { clearTimeout(timer); });
            }
            const txListener = async (receipt) => {
                // Done; return it!
                if ((await receipt.confirmations()) >= confirms) {
                    cancel();
                    try {
                        resolve(checkReceipt(receipt));
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            };
            cancellers.push(() => { this.provider.off(this.hash, txListener); });
            this.provider.on(this.hash, txListener);
            // We support replacement detection; start checking
            if (startBlock >= 0) {
                const replaceListener = async () => {
                    try {
                        // Check for a replacement; this throws only if one is found
                        await checkReplacement();
                    }
                    catch (error) {
                        // We were replaced (with enough confirms); re-throw the error
                        if (isError(error, "TRANSACTION_REPLACED")) {
                            cancel();
                            reject(error);
                            return;
                        }
                    }
                    // Rescheudle a check on the next block
                    if (!stopScanning) {
                        this.provider.once("block", replaceListener);
                    }
                };
                cancellers.push(() => { this.provider.off("block", replaceListener); });
                this.provider.once("block", replaceListener);
            }
        });
        return await waiter;
    }
    /**
     *  Returns ``true`` if this transaction has been included.
     *
     *  This is effective only as of the time the TransactionResponse
     *  was instantiated. To get up-to-date information, use
     *  [[getTransaction]].
     *
     *  This provides a Type Guard that this transaction will have
     *  non-null property values for properties that are null for
     *  unmined transactions.
     */
    isMined() {
        return (this.blockHash != null);
    }
    /**
     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
     *  transaction.
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLegacy() {
        return (this.type === 0);
    }
    /**
     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
     *  transaction. See [[link-eip-2070]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isBerlin() {
        return (this.type === 1);
    }
    /**
     *  Returns true if the transaction is a London (i.e. ``type == 2``)
     *  transaction. See [[link-eip-1559]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLondon() {
        return (this.type === 2);
    }
    /**
     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
     *  transaction. See [[link-eip-4844]].
     */
    isCancun() {
        return (this.type === 3);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that evict this transaction.
     */
    removedEvent() {
        assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createRemovedTransactionFilter(this);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that re-order this event against %%other%%.
     */
    reorderedEvent(other) {
        assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createReorderedTransactionFilter(this, other);
    }
    /**
     *  Returns a new TransactionResponse instance which has the ability to
     *  detect (and throw an error) if the transaction is replaced, which
     *  will begin scanning at %%startBlock%%.
     *
     *  This should generally not be used by developers and is intended
     *  primarily for internal use. Setting an incorrect %%startBlock%% can
     *  have devastating performance consequences if used incorrectly.
     */
    replaceableTransaction(startBlock) {
        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
        const tx = new TransactionResponse(this, this.provider);
        tx.#startBlock = startBlock;
        return tx;
    }
}
function createReorderedTransactionFilter(tx, other) {
    return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
    return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
    return { orphan: "drop-log", log: {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            address: log.address,
            data: log.data,
            topics: Object.freeze(log.topics.slice()),
            index: log.index
        } };
}

// import from provider.ts instead of index.ts to prevent circular dep
// from EtherscanProvider
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
class EventLog extends Log {
    /**
     *  The Contract Interface.
     */
    interface;
    /**
     *  The matching event.
     */
    fragment;
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    args;
    /**
     * @_ignore:
     */
    constructor(log, iface, fragment) {
        super(log, log.provider);
        const args = iface.decodeEventLog(fragment, log.data, log.topics);
        defineProperties(this, { args, fragment, interface: iface });
    }
    /**
     *  The name of the event.
     */
    get eventName() { return this.fragment.name; }
    /**
     *  The signature of the event.
     */
    get eventSignature() { return this.fragment.format(); }
}
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
class UndecodedEventLog extends Log {
    /**
     *  The error encounted when trying to decode the log.
     */
    error;
    /**
     * @_ignore:
     */
    constructor(log, error) {
        super(log, log.provider);
        defineProperties(this, { error });
    }
}
/**
 *  A **ContractTransactionReceipt** includes the parsed logs from a
 *  [[TransactionReceipt]].
 */
class ContractTransactionReceipt extends TransactionReceipt {
    #iface;
    /**
     *  @_ignore:
     */
    constructor(iface, provider, tx) {
        super(tx, provider);
        this.#iface = iface;
    }
    /**
     *  The parsed logs for any [[Log]] which has a matching event in the
     *  Contract ABI.
     */
    get logs() {
        return super.logs.map((log) => {
            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
            if (fragment) {
                try {
                    return new EventLog(log, this.#iface, fragment);
                }
                catch (error) {
                    return new UndecodedEventLog(log, error);
                }
            }
            return log;
        });
    }
}
/**
 *  A **ContractTransactionResponse** will return a
 *  [[ContractTransactionReceipt]] when waited on.
 */
class ContractTransactionResponse extends TransactionResponse {
    #iface;
    /**
     *  @_ignore:
     */
    constructor(iface, provider, tx) {
        super(tx, provider);
        this.#iface = iface;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    async wait(confirms, timeout) {
        const receipt = await super.wait(confirms, timeout);
        if (receipt == null) {
            return null;
        }
        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
    }
}
/**
 *  A **ContractUnknownEventPayload** is included as the last parameter to
 *  Contract Events when the event does not match any events in the ABI.
 */
class ContractUnknownEventPayload extends EventPayload {
    /**
     *  The log with no matching events.
     */
    log;
    /**
     *  @_event:
     */
    constructor(contract, listener, filter, log) {
        super(contract, listener, filter);
        defineProperties(this, { log });
    }
    /**
     *  Resolves to the block the event occured in.
     */
    async getBlock() {
        return await this.log.getBlock();
    }
    /**
     *  Resolves to the transaction the event occured in.
     */
    async getTransaction() {
        return await this.log.getTransaction();
    }
    /**
     *  Resolves to the transaction receipt the event occured in.
     */
    async getTransactionReceipt() {
        return await this.log.getTransactionReceipt();
    }
}
/**
 *  A **ContractEventPayload** is included as the last parameter to
 *  Contract Events when the event is known.
 */
class ContractEventPayload extends ContractUnknownEventPayload {
    /**
     *  @_ignore:
     */
    constructor(contract, listener, filter, fragment, _log) {
        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
        defineProperties(this, { args, fragment });
    }
    /**
     *  The event name.
     */
    get eventName() {
        return this.fragment.name;
    }
    /**
     *  The event signature.
     */
    get eventSignature() {
        return this.fragment.format();
    }
}

const BN_0 = BigInt(0);
function canCall(value) {
    return (value && typeof (value.call) === "function");
}
function canEstimate(value) {
    return (value && typeof (value.estimateGas) === "function");
}
function canResolve(value) {
    return (value && typeof (value.resolveName) === "function");
}
function canSend(value) {
    return (value && typeof (value.sendTransaction) === "function");
}
function getResolver(value) {
    if (value != null) {
        if (canResolve(value)) {
            return value;
        }
        if (value.provider) {
            return value.provider;
        }
    }
    return undefined;
}
class PreparedTopicFilter {
    #filter;
    fragment;
    constructor(contract, fragment, args) {
        defineProperties(this, { fragment });
        if (fragment.inputs.length < args.length) {
            throw new Error("too many arguments");
        }
        // Recursively descend into args and resolve any addresses
        const runner = getRunner(contract.runner, "resolveName");
        const resolver = canResolve(runner) ? runner : null;
        this.#filter = (async function () {
            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
                const arg = args[index];
                if (arg == null) {
                    return null;
                }
                return param.walkAsync(args[index], (type, value) => {
                    if (type === "address") {
                        if (Array.isArray(value)) {
                            return Promise.all(value.map((v) => resolveAddress(v, resolver)));
                        }
                        return resolveAddress(value, resolver);
                    }
                    return value;
                });
            }));
            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
        })();
    }
    getTopicFilter() {
        return this.#filter;
    }
}
// A = Arguments passed in as a tuple
// R = The result type of the call (i.e. if only one return type,
//     the qualified type, otherwise Result)
// D = The type the default call will return (i.e. R for view/pure,
//     TransactionResponse otherwise)
//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {
function getRunner(value, feature) {
    if (value == null) {
        return null;
    }
    if (typeof (value[feature]) === "function") {
        return value;
    }
    if (value.provider && typeof (value.provider[feature]) === "function") {
        return value.provider;
    }
    return null;
}
function getProvider(value) {
    if (value == null) {
        return null;
    }
    return value.provider || null;
}
/**
 *  @_ignore:
 */
async function copyOverrides(arg, allowed) {
    // Make sure the overrides passed in are a valid overrides object
    const _overrides = Typed.dereference(arg, "overrides");
    assertArgument(typeof (_overrides) === "object", "invalid overrides parameter", "overrides", arg);
    // Create a shallow copy (we'll deep-ify anything needed during normalizing)
    const overrides = copyRequest(_overrides);
    assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
    assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
    // Resolve any from
    if (overrides.from) {
        overrides.from = overrides.from;
    }
    return overrides;
}
/**
 *  @_ignore:
 */
async function resolveArgs(_runner, inputs, args) {
    // Recursively descend into args and resolve any addresses
    const runner = getRunner(_runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    return await Promise.all(inputs.map((param, index) => {
        return param.walkAsync(args[index], (type, value) => {
            value = Typed.dereference(value, type);
            if (type === "address") {
                return resolveAddress(value, resolver);
            }
            return value;
        });
    }));
}
function buildWrappedFallback(contract) {
    const populateTransaction = async function (overrides) {
        // If an overrides was passed in, copy it and normalize the values
        const tx = (await copyOverrides(overrides, ["data"]));
        tx.to = await contract.getAddress();
        if (tx.from) {
            tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
        }
        const iface = contract.interface;
        const noValue = (getBigInt((tx.value || BN_0), "overrides.value") === BN_0);
        const noData = ((tx.data || "0x") === "0x");
        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
            assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
        }
        assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        // Only allow payable contracts to set non-zero value
        const payable = iface.receive || (iface.fallback && iface.fallback.payable);
        assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
        // Only allow fallback contracts to set non-empty data
        assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        return tx;
    };
    const staticCall = async function (overrides) {
        const runner = getRunner(contract.runner, "call");
        assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(overrides);
        try {
            return await runner.call(tx);
        }
        catch (error) {
            if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
            }
            throw error;
        }
    };
    const send = async function (overrides) {
        const runner = contract.runner;
        assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(overrides));
        const provider = getProvider(contract.runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function (overrides) {
        const runner = getRunner(contract.runner, "estimateGas");
        assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(overrides));
    };
    const method = async (overrides) => {
        return await send(overrides);
    };
    defineProperties(method, {
        _contract: contract,
        estimateGas,
        populateTransaction,
        send, staticCall
    });
    return method;
}
function buildWrappedMethod(contract, key) {
    const getFragment = function (...args) {
        const fragment = contract.interface.getFunction(key, args);
        assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key, args }
        });
        return fragment;
    };
    const populateTransaction = async function (...args) {
        const fragment = getFragment(...args);
        // If an overrides was passed in, copy it and normalize the values
        let overrides = {};
        if (fragment.inputs.length + 1 === args.length) {
            overrides = await copyOverrides(args.pop());
            if (overrides.from) {
                overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
            }
        }
        if (fragment.inputs.length !== args.length) {
            throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
        }
        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
        return Object.assign({}, overrides, await resolveProperties({
            to: contract.getAddress(),
            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
        }));
    };
    const staticCall = async function (...args) {
        const result = await staticCallResult(...args);
        if (result.length === 1) {
            return result[0];
        }
        return result;
    };
    const send = async function (...args) {
        const runner = contract.runner;
        assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(...args));
        const provider = getProvider(contract.runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function (...args) {
        const runner = getRunner(contract.runner, "estimateGas");
        assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(...args));
    };
    const staticCallResult = async function (...args) {
        const runner = getRunner(contract.runner, "call");
        assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(...args);
        let result = "0x";
        try {
            result = await runner.call(tx);
        }
        catch (error) {
            if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
            }
            throw error;
        }
        const fragment = getFragment(...args);
        return contract.interface.decodeFunctionResult(fragment, result);
    };
    const method = async (...args) => {
        const fragment = getFragment(...args);
        if (fragment.constant) {
            return await staticCall(...args);
        }
        return await send(...args);
    };
    defineProperties(method, {
        name: contract.interface.getFunctionName(key),
        _contract: contract, _key: key,
        getFragment,
        estimateGas,
        populateTransaction,
        send, staticCall, staticCallResult,
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
            const fragment = contract.interface.getFunction(key);
            assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: { key }
            });
            return fragment;
        }
    });
    return method;
}
function buildWrappedEvent(contract, key) {
    const getFragment = function (...args) {
        const fragment = contract.interface.getEvent(key, args);
        assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key, args }
        });
        return fragment;
    };
    const method = function (...args) {
        return new PreparedTopicFilter(contract, getFragment(...args), args);
    };
    defineProperties(method, {
        name: contract.interface.getEventName(key),
        _contract: contract, _key: key,
        getFragment
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
            const fragment = contract.interface.getEvent(key);
            assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: { key }
            });
            return fragment;
        }
    });
    return method;
}
// The combination of TypeScrype, Private Fields and Proxies makes
// the world go boom; so we hide variables with some trickery keeping
// a symbol attached to each BaseContract which its sub-class (even
// via a Proxy) can reach and use to look up its internal values.
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = new WeakMap();
function setInternal(contract, values) {
    internalValues.set(contract[internal], values);
}
function getInternal(contract) {
    return internalValues.get(contract[internal]);
}
function isDeferred(value) {
    return (value && typeof (value) === "object" && ("getTopicFilter" in value) &&
        (typeof (value.getTopicFilter) === "function") && value.fragment);
}
async function getSubInfo(contract, event) {
    let topics;
    let fragment = null;
    // Convert named events to topicHash and get the fragment for
    // events which need deconstructing.
    if (Array.isArray(event)) {
        const topicHashify = function (name) {
            if (isHexString(name, 32)) {
                return name;
            }
            const fragment = contract.interface.getEvent(name);
            assertArgument(fragment, "unknown fragment", "name", name);
            return fragment.topicHash;
        };
        // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
        topics = event.map((e) => {
            if (e == null) {
                return null;
            }
            if (Array.isArray(e)) {
                return e.map(topicHashify);
            }
            return topicHashify(e);
        });
    }
    else if (event === "*") {
        topics = [null];
    }
    else if (typeof (event) === "string") {
        if (isHexString(event, 32)) {
            // Topic Hash
            topics = [event];
        }
        else {
            // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
            fragment = contract.interface.getEvent(event);
            assertArgument(fragment, "unknown fragment", "event", event);
            topics = [fragment.topicHash];
        }
    }
    else if (isDeferred(event)) {
        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`
        topics = await event.getTopicFilter();
    }
    else if ("fragment" in event) {
        // ContractEvent; e.g. `contract.filter.Transfer`
        fragment = event.fragment;
        topics = [fragment.topicHash];
    }
    else {
        assertArgument(false, "unknown event name", "event", event);
    }
    // Normalize topics and sort TopicSets
    topics = topics.map((t) => {
        if (t == null) {
            return null;
        }
        if (Array.isArray(t)) {
            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());
            if (items.length === 1) {
                return items[0];
            }
            items.sort();
            return items;
        }
        return t.toLowerCase();
    });
    const tag = topics.map((t) => {
        if (t == null) {
            return "null";
        }
        if (Array.isArray(t)) {
            return t.join("|");
        }
        return t;
    }).join("&");
    return { fragment, tag, topics };
}
async function hasSub(contract, event) {
    const { subs } = getInternal(contract);
    return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
    // Make sure our runner can actually subscribe to events
    const provider = getProvider(contract.runner);
    assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
    const { fragment, tag, topics } = await getSubInfo(contract, event);
    const { addr, subs } = getInternal(contract);
    let sub = subs.get(tag);
    if (!sub) {
        const address = (addr ? addr : contract);
        const filter = { address, topics };
        const listener = (log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
                try {
                    foundFragment = contract.interface.getEvent(log.topics[0]);
                }
                catch (error) { }
            }
            // If fragment is null, we do not deconstruct the args to emit
            if (foundFragment) {
                const _foundFragment = foundFragment;
                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
                emit(contract, event, args, (listener) => {
                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);
                });
            }
            else {
                emit(contract, event, [], (listener) => {
                    return new ContractUnknownEventPayload(contract, listener, event, log);
                });
            }
        };
        let starting = [];
        const start = () => {
            if (starting.length) {
                return;
            }
            starting.push(provider.on(filter, listener));
        };
        const stop = async () => {
            if (starting.length == 0) {
                return;
            }
            let started = starting;
            starting = [];
            await Promise.all(started);
            provider.off(filter, listener);
        };
        sub = { tag, listeners: [], start, stop };
        subs.set(tag, sub);
    }
    return sub;
}
// We use this to ensure one emit resolves before firing the next to
// ensure correct ordering (note this cannot throw and just adds the
// notice to the event queu using setTimeout).
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
    await lastEmit;
    const sub = await hasSub(contract, event);
    if (!sub) {
        return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
        const passArgs = Array.from(args);
        if (payloadFunc) {
            passArgs.push(payloadFunc(once ? null : listener));
        }
        try {
            listener.call(contract, ...passArgs);
        }
        catch (error) { }
        return !once;
    });
    if (sub.listeners.length === 0) {
        sub.stop();
        getInternal(contract).subs.delete(sub.tag);
    }
    return (count > 0);
}
async function emit(contract, event, args, payloadFunc) {
    try {
        await lastEmit;
    }
    catch (error) { }
    const resultPromise = _emit(contract, event, args, payloadFunc);
    lastEmit = resultPromise;
    return await resultPromise;
}
const passProperties = ["then"];
class BaseContract {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    target;
    /**
     *  The contract Interface.
     */
    interface;
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    runner;
    /**
     *  All the Events available on this contract.
     */
    filters;
    /**
     *  @_ignore:
     */
    [internal];
    /**
     *  The fallback or receive function if any.
     */
    fallback;
    /**
     *  Creates a new contract connected to %%target%% with the %%abi%% and
     *  optionally connected to a %%runner%% to perform operations on behalf
     *  of.
     */
    constructor(target, abi, runner, _deployTx) {
        assertArgument(typeof (target) === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
        if (runner == null) {
            runner = null;
        }
        const iface = Interface.from(abi);
        defineProperties(this, { target, runner, interface: iface });
        Object.defineProperty(this, internal, { value: {} });
        let addrPromise;
        let addr = null;
        let deployTx = null;
        if (_deployTx) {
            const provider = getProvider(runner);
            // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
        }
        let subs = new Map();
        // Resolve the target as the address
        if (typeof (target) === "string") {
            if (isHexString(target)) {
                addr = target;
                addrPromise = Promise.resolve(target);
            }
            else {
                const resolver = getRunner(runner, "resolveName");
                if (!canResolve(resolver)) {
                    throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                        operation: "resolveName"
                    });
                }
                addrPromise = resolver.resolveName(target).then((addr) => {
                    if (addr == null) {
                        throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                            value: target
                        });
                    }
                    getInternal(this).addr = addr;
                    return addr;
                });
            }
        }
        else {
            addrPromise = target.getAddress().then((addr) => {
                if (addr == null) {
                    throw new Error("TODO");
                }
                getInternal(this).addr = addr;
                return addr;
            });
        }
        // Set our private values
        setInternal(this, { addrPromise, addr, deployTx, subs });
        // Add the event filters
        const filters = new Proxy({}, {
            get: (target, prop, receiver) => {
                // Pass important checks (like `then` for Promise) through
                if (typeof (prop) === "symbol" || passProperties.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                }
                try {
                    return this.getEvent(prop);
                }
                catch (error) {
                    if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                        throw error;
                    }
                }
                return undefined;
            },
            has: (target, prop) => {
                // Pass important checks (like `then` for Promise) through
                if (passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                }
                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));
            }
        });
        defineProperties(this, { filters });
        defineProperties(this, {
            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)
        });
        // Return a Proxy that will respond to functions
        return new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                }
                // Undefined properties should return undefined
                try {
                    return target.getFunction(prop);
                }
                catch (error) {
                    if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                        throw error;
                    }
                }
                return undefined;
            },
            has: (target, prop) => {
                if (typeof (prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                }
                return target.interface.hasFunction(prop);
            }
        });
    }
    /**
     *  Return a new Contract instance with the same target and ABI, but
     *  a different %%runner%%.
     */
    connect(runner) {
        return new BaseContract(this.target, this.interface, runner);
    }
    /**
     *  Return a new Contract instance with the same ABI and runner, but
     *  a different %%target%%.
     */
    attach(target) {
        return new BaseContract(target, this.interface, this.runner);
    }
    /**
     *  Return the resolved address of this Contract.
     */
    async getAddress() { return await getInternal(this).addrPromise; }
    /**
     *  Return the deployed bytecode or null if no bytecode is found.
     */
    async getDeployedCode() {
        const provider = getProvider(this.runner);
        assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
        const code = await provider.getCode(await this.getAddress());
        if (code === "0x") {
            return null;
        }
        return code;
    }
    /**
     *  Resolve to this Contract once the bytecode has been deployed, or
     *  resolve immediately if already deployed.
     */
    async waitForDeployment() {
        // We have the deployement transaction; just use that (throws if deployement fails)
        const deployTx = this.deploymentTransaction();
        if (deployTx) {
            await deployTx.wait();
            return this;
        }
        // Check for code
        const code = await this.getDeployedCode();
        if (code != null) {
            return this;
        }
        // Make sure we can subscribe to a provider event
        const provider = getProvider(this.runner);
        assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
        return new Promise((resolve, reject) => {
            const checkCode = async () => {
                try {
                    const code = await this.getDeployedCode();
                    if (code != null) {
                        return resolve(this);
                    }
                    provider.once("block", checkCode);
                }
                catch (error) {
                    reject(error);
                }
            };
            checkCode();
        });
    }
    /**
     *  Return the transaction used to deploy this contract.
     *
     *  This is only available if this instance was returned from a
     *  [[ContractFactory]].
     */
    deploymentTransaction() {
        return getInternal(this).deployTx;
    }
    /**
     *  Return the function for a given name. This is useful when a contract
     *  method name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getFunction(key) {
        if (typeof (key) !== "string") {
            key = key.format();
        }
        const func = buildWrappedMethod(this, key);
        return func;
    }
    /**
     *  Return the event for a given name. This is useful when a contract
     *  event name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getEvent(key) {
        if (typeof (key) !== "string") {
            key = key.format();
        }
        return buildWrappedEvent(this, key);
    }
    /**
     *  @_ignore:
     */
    async queryTransaction(hash) {
        throw new Error("@TODO");
    }
    /*
    // @TODO: this is a non-backwards compatible change, but will be added
    //        in v7 and in a potential SmartContract class in an upcoming
    //        v6 release
    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
        const provider = getProvider(this.runner);
        assert(provider, "contract runner does not have a provider",
            "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });

        const receipt = await provider.getTransactionReceipt(hash);
        if (receipt == null) { return null; }

        return new ContractTransactionReceipt(this.interface, provider, receipt);
    }
    */
    /**
     *  Provide historic access to event data for %%event%% in the range
     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
     *  inclusive.
     */
    async queryFilter(event, fromBlock, toBlock) {
        if (fromBlock == null) {
            fromBlock = 0;
        }
        if (toBlock == null) {
            toBlock = "latest";
        }
        const { addr, addrPromise } = getInternal(this);
        const address = (addr ? addr : (await addrPromise));
        const { fragment, topics } = await getSubInfo(this, event);
        const filter = { address, topics, fromBlock, toBlock };
        const provider = getProvider(this.runner);
        assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
        return (await provider.getLogs(filter)).map((log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
                try {
                    foundFragment = this.interface.getEvent(log.topics[0]);
                }
                catch (error) { }
            }
            if (foundFragment) {
                try {
                    return new EventLog(log, this.interface, foundFragment);
                }
                catch (error) {
                    return new UndecodedEventLog(log, error);
                }
            }
            return new Log(log, provider);
        });
    }
    /**
     *  Add an event %%listener%% for the %%event%%.
     */
    async on(event, listener) {
        const sub = await getSub(this, "on", event);
        sub.listeners.push({ listener, once: false });
        sub.start();
        return this;
    }
    /**
     *  Add an event %%listener%% for the %%event%%, but remove the listener
     *  after it is fired once.
     */
    async once(event, listener) {
        const sub = await getSub(this, "once", event);
        sub.listeners.push({ listener, once: true });
        sub.start();
        return this;
    }
    /**
     *  Emit an %%event%% calling all listeners with %%args%%.
     *
     *  Resolves to ``true`` if any listeners were called.
     */
    async emit(event, ...args) {
        return await emit(this, event, args, null);
    }
    /**
     *  Resolves to the number of listeners of %%event%% or the total number
     *  of listeners if unspecified.
     */
    async listenerCount(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return 0;
            }
            return sub.listeners.length;
        }
        const { subs } = getInternal(this);
        let total = 0;
        for (const { listeners } of subs.values()) {
            total += listeners.length;
        }
        return total;
    }
    /**
     *  Resolves to the listeners subscribed to %%event%% or all listeners
     *  if unspecified.
     */
    async listeners(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return [];
            }
            return sub.listeners.map(({ listener }) => listener);
        }
        const { subs } = getInternal(this);
        let result = [];
        for (const { listeners } of subs.values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
    }
    /**
     *  Remove the %%listener%% from the listeners for %%event%% or remove
     *  all listeners if unspecified.
     */
    async off(event, listener) {
        const sub = await hasSub(this, event);
        if (!sub) {
            return this;
        }
        if (listener) {
            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
            if (index >= 0) {
                sub.listeners.splice(index, 1);
            }
        }
        if (listener == null || sub.listeners.length === 0) {
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
        }
        return this;
    }
    /**
     *  Remove all the listeners for %%event%% or remove all listeners if
     *  unspecified.
     */
    async removeAllListeners(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return this;
            }
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
        }
        else {
            const { subs } = getInternal(this);
            for (const { tag, stop } of subs.values()) {
                stop();
                subs.delete(tag);
            }
        }
        return this;
    }
    /**
     *  Alias for [on].
     */
    async addListener(event, listener) {
        return await this.on(event, listener);
    }
    /**
     *  Alias for [off].
     */
    async removeListener(event, listener) {
        return await this.off(event, listener);
    }
    /**
     *  Create a new Class for the %%abi%%.
     */
    static buildClass(abi) {
        class CustomContract extends BaseContract {
            constructor(address, runner = null) {
                super(address, abi, runner);
            }
        }
        return CustomContract;
    }
    ;
    /**
     *  Create a new BaseContract with a specified Interface.
     */
    static from(target, abi, runner) {
        if (runner == null) {
            runner = null;
        }
        const contract = new this(target, abi, runner);
        return contract;
    }
}
function _ContractBase() {
    return BaseContract;
}
/**
 *  A [[BaseContract]] with no type guards on its methods or events.
 */
class Contract extends _ContractBase() {
}

const nameToAddress$4 = async (name, provider) => {
    const fcrContract = new Contract(FlareContractRegistryAddress, interfaceAbis$3.IFlareContractRegistry, provider);
    return await fcrContract.getContractAddressByName(name);
};
const interfaceAbis$3 = {
    AgentInfo: AgentInfo,
    AgentSettings: AgentSettings,
    AssetManagerSettings: AssetManagerSettings,
    AvailableAgentInfo: AvailableAgentInfo,
    CollateralReservationInfo: CollateralReservationInfo,
    CollateralType: CollateralType,
    ContractRegistry: ContractRegistry,
    FtsoV2Interface: FtsoV2Interface,
    IAddressValidity: IAddressValidity,
    IAddressValidityVerification: IAddressValidityVerification,
    IAgentAlwaysAllowedMinters: IAgentAlwaysAllowedMinters,
    IAgentOwnerRegistry: IAgentOwnerRegistry,
    IAgentPing: IAgentPing,
    IAssetManager: IAssetManager,
    IAssetManagerController: IAssetManagerController,
    IAssetManagerEvents: IAssetManagerEvents,
    IBalanceDecreasingTransaction: IBalanceDecreasingTransaction,
    IBalanceDecreasingTransactionVerification: IBalanceDecreasingTransactionVerification,
    ICChainStake: ICChainStake,
    ICChainVotePower: ICChainVotePower,
    IClaimSetupManager: IClaimSetupManager,
    IConfirmedBlockHeightExists: IConfirmedBlockHeightExists,
    IConfirmedBlockHeightExistsVerification: IConfirmedBlockHeightExistsVerification,
    ICoreVaultClient: ICoreVaultClient,
    ICoreVaultClientSettings: ICoreVaultClientSettings,
    IDelegationAccount: IDelegationAccount,
    IDiamondLoupe: IDiamondLoupe,
    IEVMTransaction: IEVMTransaction,
    IEVMTransactionVerification: IEVMTransactionVerification,
    IEntityManager: IEntityManager,
    IFastUpdateIncentiveManager: IFastUpdateIncentiveManager,
    IFastUpdater: IFastUpdater,
    IFastUpdatesConfiguration: IFastUpdatesConfiguration,
    IFdcHub: IFdcHub,
    IFdcInflationConfigurations: IFdcInflationConfigurations,
    IFdcRequestFeeConfigurations: IFdcRequestFeeConfigurations,
    IFdcVerification: IFdcVerification,
    IFeeCalculator: IFeeCalculator,
    IFlareAssetRegistry: IFlareAssetRegistry,
    IFlareContractRegistry: IFlareContractRegistry,
    IFlareDaemonize: IFlareDaemonize,
    IFlareSystemsCalculator: IFlareSystemsCalculator,
    IFlareSystemsManager: IFlareSystemsManager,
    IFtso: IFtso,
    IFtsoFeedDecimals: IFtsoFeedDecimals,
    IFtsoFeedIdConverter: IFtsoFeedIdConverter,
    IFtsoFeedPublisher: IFtsoFeedPublisher,
    IFtsoGenesis: IFtsoGenesis,
    IFtsoInflationConfigurations: IFtsoInflationConfigurations,
    IFtsoManager: IFtsoManager,
    IFtsoManagerGenesis: IFtsoManagerGenesis,
    IFtsoRegistry: IFtsoRegistry,
    IFtsoRegistryGenesis: IFtsoRegistryGenesis,
    IFtsoRewardManager: IFtsoRewardManager,
    IFtsoRewardOffersManager: IFtsoRewardOffersManager,
    IGenericRewardManager: IGenericRewardManager,
    IGovernanceSettings: IGovernanceSettings,
    IGovernanceVotePower: IGovernanceVotePower,
    IGovernor: IGovernor,
    IIAddressUpdatable: IIAddressUpdatable,
    IIAddressUpdater: IIAddressUpdater,
    IIClaimSetupManager: IIClaimSetupManager,
    IICleanable: IICleanable,
    IICleanupBlockNumberManager: IICleanupBlockNumberManager,
    IICustomFeed: IICustomFeed,
    IIEntityManager: IIEntityManager,
    IIFastUpdaterView: IIFastUpdaterView,
    IIFlareSystemsCalculator: IIFlareSystemsCalculator,
    IIFlareSystemsManager: IIFlareSystemsManager,
    IIFtso: IIFtso,
    IIFtsoFeedPublisher: IIFtsoFeedPublisher,
    IIFtsoManagerProxy: IIFtsoManagerProxy,
    IIGovernanceVotePower: IIGovernanceVotePower,
    IIGovernorProposer: IIGovernorProposer,
    IINodePossessionVerifier: IINodePossessionVerifier,
    IIPollingFoundation: IIPollingFoundation,
    IIPollingManagementGroup: IIPollingManagementGroup,
    IIPublicKeyVerifier: IIPublicKeyVerifier,
    IIRNat: IIRNat,
    IIRNatAccount: IIRNatAccount,
    IIRelay: IIRelay,
    IIRewardEpochSwitchoverTrigger: IIRewardEpochSwitchoverTrigger,
    IIRewardManager: IIRewardManager,
    IISubmission: IISubmission,
    IIVPContract: IIVPContract,
    IIVPToken: IIVPToken,
    IIVoterRegistrationTrigger: IIVoterRegistrationTrigger,
    IIVoterRegistry: IIVoterRegistry,
    IIncreaseManager: IIncreaseManager,
    IJsonApi: IJsonApi,
    IJsonApiVerification: IJsonApiVerification,
    IPayment: IPayment,
    IPaymentVerification: IPaymentVerification,
    IPollingManagementGroup: IPollingManagementGroup,
    IPriceSubmitter: IPriceSubmitter,
    IRNat: IRNat,
    IRNatAccount: IRNatAccount,
    IRandomProvider: IRandomProvider,
    IRedemptionTimeExtension: IRedemptionTimeExtension,
    IReferencedPaymentNonexistence: IReferencedPaymentNonexistence,
    IReferencedPaymentNonexistenceVerification: IReferencedPaymentNonexistenceVerification,
    IRelay: IRelay,
    IRewardManager: IRewardManager,
    ISubmission: ISubmission,
    ITypeTemplate: ITypeTemplate,
    ITypeTemplateVerification: ITypeTemplateVerification,
    IVPContractEvents: IVPContractEvents,
    IVPToken: IVPToken,
    IValidatorRewardOffersManager: IValidatorRewardOffersManager,
    IVoterPreRegistry: IVoterPreRegistry,
    IVoterRegistry: IVoterRegistry,
    IVoterWhitelister: IVoterWhitelister,
    IWNat: IWNat,
    IWNatDelegationFee: IWNatDelegationFee,
    IWeb2Json: IWeb2Json,
    IWeb2JsonVerification: IWeb2JsonVerification,
    ProtocolsV2Interface: ProtocolsV2Interface,
    RandomNumberV2Interface: RandomNumberV2Interface,
    RedemptionRequestInfo: RedemptionRequestInfo,
    RedemptionTicketInfo: RedemptionTicketInfo,
    RewardsV2Interface: RewardsV2Interface,
    TestFtsoV2Interface: TestFtsoV2Interface,
};
const products$3 = {
    AssetManagerController: {
        name: "AssetManagerController",
        interface: "IAssetManagerController",
        registry: "AssetManagerController",
        abi: interfaceAbis$3.IAssetManagerController,
        getAddress: async (provider) => await nameToAddress$4("AssetManagerController", provider),
    },
    AssetManagerFXRP: {
        name: "AssetManagerFXRP",
        interface: "IAssetManager",
        registry: "AssetManagerFXRP",
        abi: interfaceAbis$3.IAssetManager,
        getAddress: async (provider) => await nameToAddress$4("AssetManagerFXRP", provider),
    },
    ClaimSetupManager: {
        name: "ClaimSetupManager",
        interface: "IClaimSetupManager",
        registry: "ClaimSetupManager",
        abi: interfaceAbis$3.IClaimSetupManager,
        getAddress: async (provider) => await nameToAddress$4("ClaimSetupManager", provider),
    },
    EntityManager: {
        name: "EntityManager",
        interface: "IEntityManager",
        registry: "EntityManager",
        abi: interfaceAbis$3.IEntityManager,
        getAddress: async (provider) => await nameToAddress$4("EntityManager", provider),
    },
    FastUpdateIncentiveManager: {
        name: "FastUpdateIncentiveManager",
        interface: "IFastUpdateIncentiveManager",
        registry: "FastUpdateIncentiveManager",
        abi: interfaceAbis$3.IFastUpdateIncentiveManager,
        getAddress: async (provider) => await nameToAddress$4("FastUpdateIncentiveManager", provider),
    },
    FastUpdater: {
        name: "FastUpdater",
        interface: "IFastUpdater",
        registry: "FastUpdater",
        abi: interfaceAbis$3.IFastUpdater,
        getAddress: async (provider) => await nameToAddress$4("FastUpdater", provider),
    },
    FastUpdatesConfiguration: {
        name: "FastUpdatesConfiguration",
        interface: "IFastUpdatesConfiguration",
        registry: "FastUpdatesConfiguration",
        abi: interfaceAbis$3.IFastUpdatesConfiguration,
        getAddress: async (provider) => await nameToAddress$4("FastUpdatesConfiguration", provider),
    },
    FdcHub: {
        name: "FdcHub",
        interface: "IFdcHub",
        registry: "FdcHub",
        abi: interfaceAbis$3.IFdcHub,
        getAddress: async (provider) => await nameToAddress$4("FdcHub", provider),
    },
    FdcRequestFeeConfigurations: {
        name: "FdcRequestFeeConfigurations",
        interface: "IFdcRequestFeeConfigurations",
        registry: "FdcRequestFeeConfigurations",
        abi: interfaceAbis$3.IFdcRequestFeeConfigurations,
        getAddress: async (provider) => await nameToAddress$4("FdcRequestFeeConfigurations", provider),
    },
    FdcVerification: {
        name: "FdcVerification",
        interface: "IFdcVerification",
        registry: "FdcVerification",
        abi: interfaceAbis$3.IFdcVerification,
        getAddress: async (provider) => await nameToAddress$4("FdcVerification", provider),
    },
    FeeCalculator: {
        name: "FeeCalculator",
        interface: "IFeeCalculator",
        registry: "FeeCalculator",
        abi: interfaceAbis$3.IFeeCalculator,
        getAddress: async (provider) => await nameToAddress$4("FeeCalculator", provider),
    },
    FlareAssetRegistry: {
        name: "FlareAssetRegistry",
        interface: "IFlareAssetRegistry",
        registry: "FlareAssetRegistry",
        abi: interfaceAbis$3.IFlareAssetRegistry,
        getAddress: async (provider) => await nameToAddress$4("FlareAssetRegistry", provider),
    },
    FlareContractRegistry: {
        name: "FlareContractRegistry",
        interface: "IFlareContractRegistry",
        registry: "FlareContractRegistry",
        abi: interfaceAbis$3.IFlareContractRegistry,
        getAddress: async (provider) => await nameToAddress$4("FlareContractRegistry", provider),
    },
    FlareSystemsCalculator: {
        name: "FlareSystemsCalculator",
        interface: "IFlareSystemsCalculator",
        registry: "FlareSystemsCalculator",
        abi: interfaceAbis$3.IFlareSystemsCalculator,
        getAddress: async (provider) => await nameToAddress$4("FlareSystemsCalculator", provider),
    },
    FlareSystemsManager: {
        name: "FlareSystemsManager",
        interface: "IFlareSystemsManager",
        registry: "FlareSystemsManager",
        abi: interfaceAbis$3.IFlareSystemsManager,
        getAddress: async (provider) => await nameToAddress$4("FlareSystemsManager", provider),
    },
    FtsoFeedDecimals: {
        name: "FtsoFeedDecimals",
        interface: "IFtsoFeedDecimals",
        registry: "FtsoFeedDecimals",
        abi: interfaceAbis$3.IFtsoFeedDecimals,
        getAddress: async (provider) => await nameToAddress$4("FtsoFeedDecimals", provider),
    },
    FtsoFeedIdConverter: {
        name: "FtsoFeedIdConverter",
        interface: "IFtsoFeedIdConverter",
        registry: "FtsoFeedIdConverter",
        abi: interfaceAbis$3.IFtsoFeedIdConverter,
        getAddress: async (provider) => await nameToAddress$4("FtsoFeedIdConverter", provider),
    },
    FtsoFeedPublisher: {
        name: "FtsoFeedPublisher",
        interface: "IFtsoFeedPublisher",
        registry: "FtsoFeedPublisher",
        abi: interfaceAbis$3.IFtsoFeedPublisher,
        getAddress: async (provider) => await nameToAddress$4("FtsoFeedPublisher", provider),
    },
    FtsoInflationConfigurations: {
        name: "FtsoInflationConfigurations",
        interface: "IFtsoInflationConfigurations",
        registry: "FtsoInflationConfigurations",
        abi: interfaceAbis$3.IFtsoInflationConfigurations,
        getAddress: async (provider) => await nameToAddress$4("FtsoInflationConfigurations", provider),
    },
    FtsoManager: {
        name: "FtsoManager",
        interface: "IFtsoManager",
        registry: "FtsoManager",
        abi: interfaceAbis$3.IFtsoManager,
        getAddress: async (provider) => await nameToAddress$4("FtsoManager", provider),
    },
    FtsoRegistry: {
        name: "FtsoRegistry",
        interface: "IFtsoRegistry",
        registry: "FtsoRegistry",
        abi: interfaceAbis$3.IFtsoRegistry,
        getAddress: async (provider) => await nameToAddress$4("FtsoRegistry", provider),
    },
    FtsoRewardManager: {
        name: "FtsoRewardManager",
        interface: "IFtsoRewardManager",
        registry: "FtsoRewardManager",
        abi: interfaceAbis$3.IFtsoRewardManager,
        getAddress: async (provider) => await nameToAddress$4("FtsoRewardManager", provider),
    },
    FtsoRewardOffersManager: {
        name: "FtsoRewardOffersManager",
        interface: "IFtsoRewardOffersManager",
        registry: "FtsoRewardOffersManager",
        abi: interfaceAbis$3.IFtsoRewardOffersManager,
        getAddress: async (provider) => await nameToAddress$4("FtsoRewardOffersManager", provider),
    },
    FtsoV2: {
        name: "FtsoV2",
        interface: "FtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis$3.FtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$4("FtsoV2", provider),
    },
    GovernanceSettings: {
        name: "GovernanceSettings",
        interface: "IGovernanceSettings",
        registry: "GovernanceSettings",
        abi: interfaceAbis$3.IGovernanceSettings,
        getAddress: async (provider) => await nameToAddress$4("GovernanceSettings", provider),
    },
    GovernanceVotePower: {
        name: "GovernanceVotePower",
        interface: "IGovernanceVotePower",
        registry: "GovernanceVotePower",
        abi: interfaceAbis$3.IGovernanceVotePower,
        getAddress: async (provider) => await nameToAddress$4("GovernanceVotePower", provider),
    },
    JsonApiVerification: {
        name: "JsonApiVerification",
        interface: "IJsonApiVerification",
        registry: "JsonApiVerification",
        abi: interfaceAbis$3.IJsonApiVerification,
        getAddress: async (provider) => await nameToAddress$4("JsonApiVerification", provider),
    },
    PriceSubmitter: {
        name: "PriceSubmitter",
        interface: "IPriceSubmitter",
        registry: "PriceSubmitter",
        abi: interfaceAbis$3.IPriceSubmitter,
        getAddress: async (provider) => await nameToAddress$4("PriceSubmitter", provider),
    },
    ProtocolsV2: {
        name: "ProtocolsV2",
        interface: "ProtocolsV2Interface",
        registry: "ProtocolsV2",
        abi: interfaceAbis$3.ProtocolsV2Interface,
        getAddress: async (provider) => await nameToAddress$4("ProtocolsV2", provider),
    },
    RandomNumberV2: {
        name: "RandomNumberV2",
        interface: "RandomNumberV2Interface",
        registry: "RandomNumberV2",
        abi: interfaceAbis$3.RandomNumberV2Interface,
        getAddress: async (provider) => await nameToAddress$4("RandomNumberV2", provider),
    },
    Relay: {
        name: "Relay",
        interface: "IRelay",
        registry: "Relay",
        abi: interfaceAbis$3.IRelay,
        getAddress: async (provider) => await nameToAddress$4("Relay", provider),
    },
    RewardManager: {
        name: "RewardManager",
        interface: "IRewardManager",
        registry: "RewardManager",
        abi: interfaceAbis$3.IRewardManager,
        getAddress: async (provider) => await nameToAddress$4("RewardManager", provider),
    },
    RewardsV2: {
        name: "RewardsV2",
        interface: "RewardsV2Interface",
        registry: "RewardsV2",
        abi: interfaceAbis$3.RewardsV2Interface,
        getAddress: async (provider) => await nameToAddress$4("RewardsV2", provider),
    },
    Submission: {
        name: "Submission",
        interface: "ISubmission",
        registry: "Submission",
        abi: interfaceAbis$3.ISubmission,
        getAddress: async (provider) => await nameToAddress$4("Submission", provider),
    },
    TestFtsoV2: {
        name: "TestFtsoV2",
        interface: "TestFtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis$3.TestFtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$4("FtsoV2", provider),
    },
    VoterRegistry: {
        name: "VoterRegistry",
        interface: "IVoterRegistry",
        registry: "VoterRegistry",
        abi: interfaceAbis$3.IVoterRegistry,
        getAddress: async (provider) => await nameToAddress$4("VoterRegistry", provider),
    },
    VoterWhitelister: {
        name: "VoterWhitelister",
        interface: "IVoterWhitelister",
        registry: "VoterWhitelister",
        abi: interfaceAbis$3.IVoterWhitelister,
        getAddress: async (provider) => await nameToAddress$4("VoterWhitelister", provider),
    },
    WNat: {
        name: "WNat",
        interface: "IWNat",
        registry: "WNat",
        abi: interfaceAbis$3.IWNat,
        getAddress: async (provider) => await nameToAddress$4("WNat", provider),
    },
    WNatDelegationFee: {
        name: "WNatDelegationFee",
        interface: "IWNatDelegationFee",
        registry: "WNatDelegationFee",
        abi: interfaceAbis$3.IWNatDelegationFee,
        getAddress: async (provider) => await nameToAddress$4("WNatDelegationFee", provider),
    },
};

const nameToAbi$4 = (name) => {
    var _a;
    try {
        const abiData = (_a = products$3[name]) === null || _a === void 0 ? void 0 : _a.abi;
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network contract with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network contract with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network contract with name "${name}".`);
};
const interfaceToAbi$4 = (name) => {
    try {
        const abiData = interfaceAbis$3[name];
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network interface with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network interface with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network interface with name "${name}".`);
};

var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    interfaceAbis: interfaceAbis$3,
    interfaceToAbi: interfaceToAbi$4,
    nameToAbi: nameToAbi$4,
    products: products$3
});

const nameToAddress$3 = async (name, provider) => {
    const fcrContract = new Contract(FlareContractRegistryAddress, interfaceAbis$2.IFlareContractRegistry, provider);
    return await fcrContract.getContractAddressByName(name);
};
const interfaceAbis$2 = {
    AgentInfo: AgentInfo$1,
    AgentSettings: AgentSettings$1,
    AssetManagerSettings: AssetManagerSettings$1,
    AvailableAgentInfo: AvailableAgentInfo$1,
    CollateralReservationInfo: CollateralReservationInfo$1,
    CollateralType: CollateralType$1,
    ContractRegistry: ContractRegistry$1,
    FtsoV2Interface: FtsoV2Interface$1,
    IAddressBinder: IAddressBinder,
    IAddressValidity: IAddressValidity$1,
    IAddressValidityVerification: IAddressValidityVerification$1,
    IAgentAlwaysAllowedMinters: IAgentAlwaysAllowedMinters$1,
    IAgentOwnerRegistry: IAgentOwnerRegistry$1,
    IAgentPing: IAgentPing$1,
    IAssetManager: IAssetManager$1,
    IAssetManagerController: IAssetManagerController$1,
    IAssetManagerEvents: IAssetManagerEvents$1,
    IBalanceDecreasingTransaction: IBalanceDecreasingTransaction$1,
    IBalanceDecreasingTransactionVerification: IBalanceDecreasingTransactionVerification$1,
    ICChainStake: ICChainStake$1,
    ICChainVotePower: ICChainVotePower$1,
    IClaimSetupManager: IClaimSetupManager$1,
    IConfirmedBlockHeightExists: IConfirmedBlockHeightExists$1,
    IConfirmedBlockHeightExistsVerification: IConfirmedBlockHeightExistsVerification$1,
    ICoreVaultClient: ICoreVaultClient$1,
    ICoreVaultClientSettings: ICoreVaultClientSettings$1,
    IDelegationAccount: IDelegationAccount$1,
    IDiamondLoupe: IDiamondLoupe$1,
    IDistributionToDelegators: IDistributionToDelegators,
    IEVMTransaction: IEVMTransaction$1,
    IEVMTransactionVerification: IEVMTransactionVerification$1,
    IEntityManager: IEntityManager$1,
    IFastUpdateIncentiveManager: IFastUpdateIncentiveManager$1,
    IFastUpdater: IFastUpdater$1,
    IFastUpdatesConfiguration: IFastUpdatesConfiguration$1,
    IFdcHub: IFdcHub$1,
    IFdcInflationConfigurations: IFdcInflationConfigurations$1,
    IFdcRequestFeeConfigurations: IFdcRequestFeeConfigurations$1,
    IFdcVerification: IFdcVerification$1,
    IFeeCalculator: IFeeCalculator$1,
    IFlareAssetRegistry: IFlareAssetRegistry$1,
    IFlareContractRegistry: IFlareContractRegistry$1,
    IFlareDaemonize: IFlareDaemonize$1,
    IFlareSystemsCalculator: IFlareSystemsCalculator$1,
    IFlareSystemsManager: IFlareSystemsManager$1,
    IFtso: IFtso$1,
    IFtsoFeedDecimals: IFtsoFeedDecimals$1,
    IFtsoFeedIdConverter: IFtsoFeedIdConverter$1,
    IFtsoFeedPublisher: IFtsoFeedPublisher$1,
    IFtsoGenesis: IFtsoGenesis$1,
    IFtsoInflationConfigurations: IFtsoInflationConfigurations$1,
    IFtsoManager: IFtsoManager$1,
    IFtsoManagerGenesis: IFtsoManagerGenesis$1,
    IFtsoRegistry: IFtsoRegistry$1,
    IFtsoRegistryGenesis: IFtsoRegistryGenesis$1,
    IFtsoRewardManager: IFtsoRewardManager$1,
    IFtsoRewardOffersManager: IFtsoRewardOffersManager$1,
    IGenericRewardManager: IGenericRewardManager$1,
    IGovernanceSettings: IGovernanceSettings$1,
    IGovernanceVotePower: IGovernanceVotePower$1,
    IGovernor: IGovernor$1,
    IIAddressUpdatable: IIAddressUpdatable$1,
    IIAddressUpdater: IIAddressUpdater$1,
    IIClaimSetupManager: IIClaimSetupManager$1,
    IICleanable: IICleanable$1,
    IICleanupBlockNumberManager: IICleanupBlockNumberManager$1,
    IICustomFeed: IICustomFeed$1,
    IIEntityManager: IIEntityManager$1,
    IIFastUpdaterView: IIFastUpdaterView$1,
    IIFlareSystemsCalculator: IIFlareSystemsCalculator$1,
    IIFlareSystemsManager: IIFlareSystemsManager$1,
    IIFtso: IIFtso$1,
    IIFtsoFeedPublisher: IIFtsoFeedPublisher$1,
    IIFtsoManagerProxy: IIFtsoManagerProxy$1,
    IIGovernanceVotePower: IIGovernanceVotePower$1,
    IIGovernorProposer: IIGovernorProposer$1,
    IINodePossessionVerifier: IINodePossessionVerifier$1,
    IIPollingFoundation: IIPollingFoundation$1,
    IIPollingManagementGroup: IIPollingManagementGroup$1,
    IIPublicKeyVerifier: IIPublicKeyVerifier$1,
    IIRNat: IIRNat$1,
    IIRNatAccount: IIRNatAccount$1,
    IIRelay: IIRelay$1,
    IIRewardEpochSwitchoverTrigger: IIRewardEpochSwitchoverTrigger$1,
    IIRewardManager: IIRewardManager$1,
    IISubmission: IISubmission$1,
    IIVPContract: IIVPContract$1,
    IIVPToken: IIVPToken$1,
    IIVoterRegistrationTrigger: IIVoterRegistrationTrigger$1,
    IIVoterRegistry: IIVoterRegistry$1,
    IIncreaseManager: IIncreaseManager$1,
    IJsonApi: IJsonApi$1,
    IJsonApiVerification: IJsonApiVerification$1,
    IPChainStakeMirror: IPChainStakeMirror,
    IPChainStakeMirrorMultiSigVoting: IPChainStakeMirrorMultiSigVoting,
    IPChainStakeMirrorVerifier: IPChainStakeMirrorVerifier,
    IPChainVotePower: IPChainVotePower,
    IPayment: IPayment$1,
    IPaymentVerification: IPaymentVerification$1,
    IPollingFtso: IPollingFtso,
    IPollingManagementGroup: IPollingManagementGroup$1,
    IPriceSubmitter: IPriceSubmitter$1,
    IRNat: IRNat$1,
    IRNatAccount: IRNatAccount$1,
    IRandomProvider: IRandomProvider$1,
    IRedemptionTimeExtension: IRedemptionTimeExtension$1,
    IReferencedPaymentNonexistence: IReferencedPaymentNonexistence$1,
    IReferencedPaymentNonexistenceVerification: IReferencedPaymentNonexistenceVerification$1,
    IRelay: IRelay$1,
    IRewardManager: IRewardManager$1,
    ISubmission: ISubmission$1,
    ITypeTemplate: ITypeTemplate$1,
    ITypeTemplateVerification: ITypeTemplateVerification$1,
    IVPContractEvents: IVPContractEvents$1,
    IVPToken: IVPToken$1,
    IValidatorRegistry: IValidatorRegistry,
    IValidatorRewardOffersManager: IValidatorRewardOffersManager$1,
    IVoterPreRegistry: IVoterPreRegistry$1,
    IVoterRegistry: IVoterRegistry$1,
    IVoterWhitelister: IVoterWhitelister$1,
    IWNat: IWNat$1,
    IWNatDelegationFee: IWNatDelegationFee$1,
    IWeb2Json: IWeb2Json$1,
    IWeb2JsonVerification: IWeb2JsonVerification$1,
    ProtocolsV2Interface: ProtocolsV2Interface$1,
    RandomNumberV2Interface: RandomNumberV2Interface$1,
    RedemptionRequestInfo: RedemptionRequestInfo$1,
    RedemptionTicketInfo: RedemptionTicketInfo$1,
    RewardsV2Interface: RewardsV2Interface$1,
    TestFtsoV2Interface: TestFtsoV2Interface$1,
};
const products$2 = {
    AssetManagerController: {
        name: "AssetManagerController",
        interface: "IAssetManagerController",
        registry: "AssetManagerController",
        abi: interfaceAbis$2.IAssetManagerController,
        getAddress: async (provider) => await nameToAddress$3("AssetManagerController", provider),
    },
    AssetManagerFXRP: {
        name: "AssetManagerFXRP",
        interface: "IAssetManager",
        registry: "AssetManagerFXRP",
        abi: interfaceAbis$2.IAssetManager,
        getAddress: async (provider) => await nameToAddress$3("AssetManagerFXRP", provider),
    },
    ClaimSetupManager: {
        name: "ClaimSetupManager",
        interface: "IClaimSetupManager",
        registry: "ClaimSetupManager",
        abi: interfaceAbis$2.IClaimSetupManager,
        getAddress: async (provider) => await nameToAddress$3("ClaimSetupManager", provider),
    },
    EntityManager: {
        name: "EntityManager",
        interface: "IEntityManager",
        registry: "EntityManager",
        abi: interfaceAbis$2.IEntityManager,
        getAddress: async (provider) => await nameToAddress$3("EntityManager", provider),
    },
    FastUpdateIncentiveManager: {
        name: "FastUpdateIncentiveManager",
        interface: "IFastUpdateIncentiveManager",
        registry: "FastUpdateIncentiveManager",
        abi: interfaceAbis$2.IFastUpdateIncentiveManager,
        getAddress: async (provider) => await nameToAddress$3("FastUpdateIncentiveManager", provider),
    },
    FastUpdater: {
        name: "FastUpdater",
        interface: "IFastUpdater",
        registry: "FastUpdater",
        abi: interfaceAbis$2.IFastUpdater,
        getAddress: async (provider) => await nameToAddress$3("FastUpdater", provider),
    },
    FastUpdatesConfiguration: {
        name: "FastUpdatesConfiguration",
        interface: "IFastUpdatesConfiguration",
        registry: "FastUpdatesConfiguration",
        abi: interfaceAbis$2.IFastUpdatesConfiguration,
        getAddress: async (provider) => await nameToAddress$3("FastUpdatesConfiguration", provider),
    },
    FdcHub: {
        name: "FdcHub",
        interface: "IFdcHub",
        registry: "FdcHub",
        abi: interfaceAbis$2.IFdcHub,
        getAddress: async (provider) => await nameToAddress$3("FdcHub", provider),
    },
    FdcRequestFeeConfigurations: {
        name: "FdcRequestFeeConfigurations",
        interface: "IFdcRequestFeeConfigurations",
        registry: "FdcRequestFeeConfigurations",
        abi: interfaceAbis$2.IFdcRequestFeeConfigurations,
        getAddress: async (provider) => await nameToAddress$3("FdcRequestFeeConfigurations", provider),
    },
    FdcVerification: {
        name: "FdcVerification",
        interface: "IFdcVerification",
        registry: "FdcVerification",
        abi: interfaceAbis$2.IFdcVerification,
        getAddress: async (provider) => await nameToAddress$3("FdcVerification", provider),
    },
    FeeCalculator: {
        name: "FeeCalculator",
        interface: "IFeeCalculator",
        registry: "FeeCalculator",
        abi: interfaceAbis$2.IFeeCalculator,
        getAddress: async (provider) => await nameToAddress$3("FeeCalculator", provider),
    },
    FlareAssetRegistry: {
        name: "FlareAssetRegistry",
        interface: "IFlareAssetRegistry",
        registry: "FlareAssetRegistry",
        abi: interfaceAbis$2.IFlareAssetRegistry,
        getAddress: async (provider) => await nameToAddress$3("FlareAssetRegistry", provider),
    },
    FlareContractRegistry: {
        name: "FlareContractRegistry",
        interface: "IFlareContractRegistry",
        registry: "FlareContractRegistry",
        abi: interfaceAbis$2.IFlareContractRegistry,
        getAddress: async (provider) => await nameToAddress$3("FlareContractRegistry", provider),
    },
    FlareSystemsCalculator: {
        name: "FlareSystemsCalculator",
        interface: "IFlareSystemsCalculator",
        registry: "FlareSystemsCalculator",
        abi: interfaceAbis$2.IFlareSystemsCalculator,
        getAddress: async (provider) => await nameToAddress$3("FlareSystemsCalculator", provider),
    },
    FlareSystemsManager: {
        name: "FlareSystemsManager",
        interface: "IFlareSystemsManager",
        registry: "FlareSystemsManager",
        abi: interfaceAbis$2.IFlareSystemsManager,
        getAddress: async (provider) => await nameToAddress$3("FlareSystemsManager", provider),
    },
    FtsoFeedDecimals: {
        name: "FtsoFeedDecimals",
        interface: "IFtsoFeedDecimals",
        registry: "FtsoFeedDecimals",
        abi: interfaceAbis$2.IFtsoFeedDecimals,
        getAddress: async (provider) => await nameToAddress$3("FtsoFeedDecimals", provider),
    },
    FtsoFeedIdConverter: {
        name: "FtsoFeedIdConverter",
        interface: "IFtsoFeedIdConverter",
        registry: "FtsoFeedIdConverter",
        abi: interfaceAbis$2.IFtsoFeedIdConverter,
        getAddress: async (provider) => await nameToAddress$3("FtsoFeedIdConverter", provider),
    },
    FtsoFeedPublisher: {
        name: "FtsoFeedPublisher",
        interface: "IFtsoFeedPublisher",
        registry: "FtsoFeedPublisher",
        abi: interfaceAbis$2.IFtsoFeedPublisher,
        getAddress: async (provider) => await nameToAddress$3("FtsoFeedPublisher", provider),
    },
    FtsoInflationConfigurations: {
        name: "FtsoInflationConfigurations",
        interface: "IFtsoInflationConfigurations",
        registry: "FtsoInflationConfigurations",
        abi: interfaceAbis$2.IFtsoInflationConfigurations,
        getAddress: async (provider) => await nameToAddress$3("FtsoInflationConfigurations", provider),
    },
    FtsoManager: {
        name: "FtsoManager",
        interface: "IFtsoManager",
        registry: "FtsoManager",
        abi: interfaceAbis$2.IFtsoManager,
        getAddress: async (provider) => await nameToAddress$3("FtsoManager", provider),
    },
    FtsoRegistry: {
        name: "FtsoRegistry",
        interface: "IFtsoRegistry",
        registry: "FtsoRegistry",
        abi: interfaceAbis$2.IFtsoRegistry,
        getAddress: async (provider) => await nameToAddress$3("FtsoRegistry", provider),
    },
    FtsoRewardManager: {
        name: "FtsoRewardManager",
        interface: "IFtsoRewardManager",
        registry: "FtsoRewardManager",
        abi: interfaceAbis$2.IFtsoRewardManager,
        getAddress: async (provider) => await nameToAddress$3("FtsoRewardManager", provider),
    },
    FtsoRewardOffersManager: {
        name: "FtsoRewardOffersManager",
        interface: "IFtsoRewardOffersManager",
        registry: "FtsoRewardOffersManager",
        abi: interfaceAbis$2.IFtsoRewardOffersManager,
        getAddress: async (provider) => await nameToAddress$3("FtsoRewardOffersManager", provider),
    },
    FtsoV2: {
        name: "FtsoV2",
        interface: "FtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis$2.FtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$3("FtsoV2", provider),
    },
    GovernanceSettings: {
        name: "GovernanceSettings",
        interface: "IGovernanceSettings",
        registry: "GovernanceSettings",
        abi: interfaceAbis$2.IGovernanceSettings,
        getAddress: async (provider) => await nameToAddress$3("GovernanceSettings", provider),
    },
    GovernanceVotePower: {
        name: "GovernanceVotePower",
        interface: "IGovernanceVotePower",
        registry: "GovernanceVotePower",
        abi: interfaceAbis$2.IGovernanceVotePower,
        getAddress: async (provider) => await nameToAddress$3("GovernanceVotePower", provider),
    },
    JsonApiVerification: {
        name: "JsonApiVerification",
        interface: "IJsonApiVerification",
        registry: "JsonApiVerification",
        abi: interfaceAbis$2.IJsonApiVerification,
        getAddress: async (provider) => await nameToAddress$3("JsonApiVerification", provider),
    },
    PriceSubmitter: {
        name: "PriceSubmitter",
        interface: "IPriceSubmitter",
        registry: "PriceSubmitter",
        abi: interfaceAbis$2.IPriceSubmitter,
        getAddress: async (provider) => await nameToAddress$3("PriceSubmitter", provider),
    },
    ProtocolsV2: {
        name: "ProtocolsV2",
        interface: "ProtocolsV2Interface",
        registry: "ProtocolsV2",
        abi: interfaceAbis$2.ProtocolsV2Interface,
        getAddress: async (provider) => await nameToAddress$3("ProtocolsV2", provider),
    },
    RandomNumberV2: {
        name: "RandomNumberV2",
        interface: "RandomNumberV2Interface",
        registry: "RandomNumberV2",
        abi: interfaceAbis$2.RandomNumberV2Interface,
        getAddress: async (provider) => await nameToAddress$3("RandomNumberV2", provider),
    },
    Relay: {
        name: "Relay",
        interface: "IRelay",
        registry: "Relay",
        abi: interfaceAbis$2.IRelay,
        getAddress: async (provider) => await nameToAddress$3("Relay", provider),
    },
    RewardManager: {
        name: "RewardManager",
        interface: "IRewardManager",
        registry: "RewardManager",
        abi: interfaceAbis$2.IRewardManager,
        getAddress: async (provider) => await nameToAddress$3("RewardManager", provider),
    },
    RewardsV2: {
        name: "RewardsV2",
        interface: "RewardsV2Interface",
        registry: "RewardsV2",
        abi: interfaceAbis$2.RewardsV2Interface,
        getAddress: async (provider) => await nameToAddress$3("RewardsV2", provider),
    },
    Submission: {
        name: "Submission",
        interface: "ISubmission",
        registry: "Submission",
        abi: interfaceAbis$2.ISubmission,
        getAddress: async (provider) => await nameToAddress$3("Submission", provider),
    },
    TestFtsoV2: {
        name: "TestFtsoV2",
        interface: "TestFtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis$2.TestFtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$3("FtsoV2", provider),
    },
    ValidatorRewardManager: {
        name: "ValidatorRewardManager",
        interface: "IGenericRewardManager",
        registry: "ValidatorRewardManager",
        abi: interfaceAbis$2.IGenericRewardManager,
        getAddress: async (provider) => await nameToAddress$3("ValidatorRewardManager", provider),
    },
    VoterRegistry: {
        name: "VoterRegistry",
        interface: "IVoterRegistry",
        registry: "VoterRegistry",
        abi: interfaceAbis$2.IVoterRegistry,
        getAddress: async (provider) => await nameToAddress$3("VoterRegistry", provider),
    },
    VoterWhitelister: {
        name: "VoterWhitelister",
        interface: "IVoterWhitelister",
        registry: "VoterWhitelister",
        abi: interfaceAbis$2.IVoterWhitelister,
        getAddress: async (provider) => await nameToAddress$3("VoterWhitelister", provider),
    },
    WNat: {
        name: "WNat",
        interface: "IWNat",
        registry: "WNat",
        abi: interfaceAbis$2.IWNat,
        getAddress: async (provider) => await nameToAddress$3("WNat", provider),
    },
    WNatDelegationFee: {
        name: "WNatDelegationFee",
        interface: "IWNatDelegationFee",
        registry: "WNatDelegationFee",
        abi: interfaceAbis$2.IWNatDelegationFee,
        getAddress: async (provider) => await nameToAddress$3("WNatDelegationFee", provider),
    },
};

const nameToAbi$3 = (name) => {
    var _a;
    try {
        const abiData = (_a = products$2[name]) === null || _a === void 0 ? void 0 : _a.abi;
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network contract with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network contract with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network contract with name "${name}".`);
};
const interfaceToAbi$3 = (name) => {
    try {
        const abiData = interfaceAbis$2[name];
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network interface with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network interface with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network interface with name "${name}".`);
};

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    interfaceAbis: interfaceAbis$2,
    interfaceToAbi: interfaceToAbi$3,
    nameToAbi: nameToAbi$3,
    products: products$2
});

const nameToAddress$2 = async (name, provider) => {
    const fcrContract = new Contract(FlareContractRegistryAddress, interfaceAbis$1.IFlareContractRegistry, provider);
    return await fcrContract.getContractAddressByName(name);
};
const interfaceAbis$1 = {
    AgentInfo: AgentInfo$2,
    AgentSettings: AgentSettings$2,
    AssetManagerSettings: AssetManagerSettings$2,
    AvailableAgentInfo: AvailableAgentInfo$2,
    CollateralReservationInfo: CollateralReservationInfo$2,
    CollateralType: CollateralType$2,
    ContractRegistry: ContractRegistry$2,
    FtsoV2Interface: FtsoV2Interface$2,
    IAddressBinder: IAddressBinder$1,
    IAddressValidity: IAddressValidity$2,
    IAddressValidityVerification: IAddressValidityVerification$2,
    IAgentAlwaysAllowedMinters: IAgentAlwaysAllowedMinters$2,
    IAgentOwnerRegistry: IAgentOwnerRegistry$2,
    IAgentPing: IAgentPing$2,
    IAssetManager: IAssetManager$2,
    IAssetManagerController: IAssetManagerController$2,
    IAssetManagerEvents: IAssetManagerEvents$2,
    IBalanceDecreasingTransaction: IBalanceDecreasingTransaction$2,
    IBalanceDecreasingTransactionVerification: IBalanceDecreasingTransactionVerification$2,
    ICChainStake: ICChainStake$2,
    ICChainVotePower: ICChainVotePower$2,
    IClaimSetupManager: IClaimSetupManager$2,
    IConfirmedBlockHeightExists: IConfirmedBlockHeightExists$2,
    IConfirmedBlockHeightExistsVerification: IConfirmedBlockHeightExistsVerification$2,
    ICoreVault: ICoreVault,
    ICoreVaultSettings: ICoreVaultSettings,
    IDelegationAccount: IDelegationAccount$2,
    IDiamondLoupe: IDiamondLoupe$2,
    IDistributionToDelegators: IDistributionToDelegators$1,
    IEVMTransaction: IEVMTransaction$2,
    IEVMTransactionVerification: IEVMTransactionVerification$2,
    IEntityManager: IEntityManager$2,
    IFastUpdateIncentiveManager: IFastUpdateIncentiveManager$2,
    IFastUpdater: IFastUpdater$2,
    IFastUpdatesConfiguration: IFastUpdatesConfiguration$2,
    IFdcHub: IFdcHub$2,
    IFdcInflationConfigurations: IFdcInflationConfigurations$2,
    IFdcRequestFeeConfigurations: IFdcRequestFeeConfigurations$2,
    IFdcVerification: IFdcVerification$2,
    IFeeCalculator: IFeeCalculator$2,
    IFlareAssetRegistry: IFlareAssetRegistry$2,
    IFlareContractRegistry: IFlareContractRegistry$2,
    IFlareDaemonize: IFlareDaemonize$2,
    IFlareSystemsCalculator: IFlareSystemsCalculator$2,
    IFlareSystemsManager: IFlareSystemsManager$2,
    IFtso: IFtso$2,
    IFtsoFeedDecimals: IFtsoFeedDecimals$2,
    IFtsoFeedIdConverter: IFtsoFeedIdConverter$2,
    IFtsoFeedPublisher: IFtsoFeedPublisher$2,
    IFtsoGenesis: IFtsoGenesis$2,
    IFtsoInflationConfigurations: IFtsoInflationConfigurations$2,
    IFtsoManager: IFtsoManager$2,
    IFtsoManagerGenesis: IFtsoManagerGenesis$2,
    IFtsoRegistry: IFtsoRegistry$2,
    IFtsoRegistryGenesis: IFtsoRegistryGenesis$2,
    IFtsoRewardManager: IFtsoRewardManager$2,
    IFtsoRewardOffersManager: IFtsoRewardOffersManager$2,
    IGenericRewardManager: IGenericRewardManager$2,
    IGovernanceSettings: IGovernanceSettings$2,
    IGovernanceVotePower: IGovernanceVotePower$2,
    IGovernor: IGovernor$2,
    IIAddressUpdatable: IIAddressUpdatable$2,
    IIAddressUpdater: IIAddressUpdater$2,
    IIClaimSetupManager: IIClaimSetupManager$2,
    IICleanable: IICleanable$2,
    IICleanupBlockNumberManager: IICleanupBlockNumberManager$2,
    IICustomFeed: IICustomFeed$2,
    IIEntityManager: IIEntityManager$2,
    IIFastUpdaterView: IIFastUpdaterView$2,
    IIFlareSystemsCalculator: IIFlareSystemsCalculator$2,
    IIFlareSystemsManager: IIFlareSystemsManager$2,
    IIFtso: IIFtso$2,
    IIFtsoFeedPublisher: IIFtsoFeedPublisher$2,
    IIFtsoManagerProxy: IIFtsoManagerProxy$2,
    IIGovernanceVotePower: IIGovernanceVotePower$2,
    IIGovernorProposer: IIGovernorProposer$2,
    IINodePossessionVerifier: IINodePossessionVerifier$2,
    IIPollingFoundation: IIPollingFoundation$2,
    IIPollingManagementGroup: IIPollingManagementGroup$2,
    IIPublicKeyVerifier: IIPublicKeyVerifier$2,
    IIRNat: IIRNat$2,
    IIRNatAccount: IIRNatAccount$2,
    IIRelay: IIRelay$2,
    IIRewardEpochSwitchoverTrigger: IIRewardEpochSwitchoverTrigger$2,
    IIRewardManager: IIRewardManager$2,
    IISubmission: IISubmission$2,
    IIVPContract: IIVPContract$2,
    IIVPToken: IIVPToken$2,
    IIVoterRegistrationTrigger: IIVoterRegistrationTrigger$2,
    IIVoterRegistry: IIVoterRegistry$2,
    IIncreaseManager: IIncreaseManager$2,
    IJsonApi: IJsonApi$2,
    IJsonApiVerification: IJsonApiVerification$2,
    IPChainStakeMirror: IPChainStakeMirror$1,
    IPChainStakeMirrorMultiSigVoting: IPChainStakeMirrorMultiSigVoting$1,
    IPChainStakeMirrorVerifier: IPChainStakeMirrorVerifier$1,
    IPChainVotePower: IPChainVotePower$1,
    IPayment: IPayment$2,
    IPaymentVerification: IPaymentVerification$2,
    IPollingFtso: IPollingFtso$1,
    IPollingManagementGroup: IPollingManagementGroup$2,
    IPriceSubmitter: IPriceSubmitter$2,
    IRNat: IRNat$2,
    IRNatAccount: IRNatAccount$2,
    IRandomProvider: IRandomProvider$2,
    IRedemptionTimeExtension: IRedemptionTimeExtension$2,
    IReferencedPaymentNonexistence: IReferencedPaymentNonexistence$2,
    IReferencedPaymentNonexistenceVerification: IReferencedPaymentNonexistenceVerification$2,
    IRelay: IRelay$2,
    IRewardManager: IRewardManager$2,
    ISubmission: ISubmission$2,
    ITransferFees: ITransferFees,
    ITypeTemplate: ITypeTemplate$2,
    ITypeTemplateVerification: ITypeTemplateVerification$2,
    IVPContractEvents: IVPContractEvents$2,
    IVPToken: IVPToken$2,
    IValidatorRegistry: IValidatorRegistry$1,
    IValidatorRewardOffersManager: IValidatorRewardOffersManager$2,
    IVoterPreRegistry: IVoterPreRegistry$2,
    IVoterRegistry: IVoterRegistry$2,
    IVoterWhitelister: IVoterWhitelister$2,
    IWNat: IWNat$2,
    IWNatDelegationFee: IWNatDelegationFee$2,
    IWeb2Json: IWeb2Json$2,
    IWeb2JsonVerification: IWeb2JsonVerification$2,
    IWhitelist: IWhitelist,
    ProtocolsV2Interface: ProtocolsV2Interface$2,
    RandomNumberV2Interface: RandomNumberV2Interface$2,
    RedemptionRequestInfo: RedemptionRequestInfo$2,
    RedemptionTicketInfo: RedemptionTicketInfo$2,
    RewardsV2Interface: RewardsV2Interface$2,
    TestFtsoV2Interface: TestFtsoV2Interface$2,
};
const products$1 = {
    AssetManagerController: {
        name: "AssetManagerController",
        interface: "IAssetManagerController",
        registry: "AssetManagerController",
        abi: interfaceAbis$1.IAssetManagerController,
        getAddress: async (provider) => await nameToAddress$2("AssetManagerController", provider),
    },
    ClaimSetupManager: {
        name: "ClaimSetupManager",
        interface: "IClaimSetupManager",
        registry: "ClaimSetupManager",
        abi: interfaceAbis$1.IClaimSetupManager,
        getAddress: async (provider) => await nameToAddress$2("ClaimSetupManager", provider),
    },
    EntityManager: {
        name: "EntityManager",
        interface: "IEntityManager",
        registry: "EntityManager",
        abi: interfaceAbis$1.IEntityManager,
        getAddress: async (provider) => await nameToAddress$2("EntityManager", provider),
    },
    FastUpdateIncentiveManager: {
        name: "FastUpdateIncentiveManager",
        interface: "IFastUpdateIncentiveManager",
        registry: "FastUpdateIncentiveManager",
        abi: interfaceAbis$1.IFastUpdateIncentiveManager,
        getAddress: async (provider) => await nameToAddress$2("FastUpdateIncentiveManager", provider),
    },
    FastUpdater: {
        name: "FastUpdater",
        interface: "IFastUpdater",
        registry: "FastUpdater",
        abi: interfaceAbis$1.IFastUpdater,
        getAddress: async (provider) => await nameToAddress$2("FastUpdater", provider),
    },
    FastUpdatesConfiguration: {
        name: "FastUpdatesConfiguration",
        interface: "IFastUpdatesConfiguration",
        registry: "FastUpdatesConfiguration",
        abi: interfaceAbis$1.IFastUpdatesConfiguration,
        getAddress: async (provider) => await nameToAddress$2("FastUpdatesConfiguration", provider),
    },
    FdcHub: {
        name: "FdcHub",
        interface: "IFdcHub",
        registry: "FdcHub",
        abi: interfaceAbis$1.IFdcHub,
        getAddress: async (provider) => await nameToAddress$2("FdcHub", provider),
    },
    FdcRequestFeeConfigurations: {
        name: "FdcRequestFeeConfigurations",
        interface: "IFdcRequestFeeConfigurations",
        registry: "FdcRequestFeeConfigurations",
        abi: interfaceAbis$1.IFdcRequestFeeConfigurations,
        getAddress: async (provider) => await nameToAddress$2("FdcRequestFeeConfigurations", provider),
    },
    FdcVerification: {
        name: "FdcVerification",
        interface: "IFdcVerification",
        registry: "FdcVerification",
        abi: interfaceAbis$1.IFdcVerification,
        getAddress: async (provider) => await nameToAddress$2("FdcVerification", provider),
    },
    FeeCalculator: {
        name: "FeeCalculator",
        interface: "IFeeCalculator",
        registry: "FeeCalculator",
        abi: interfaceAbis$1.IFeeCalculator,
        getAddress: async (provider) => await nameToAddress$2("FeeCalculator", provider),
    },
    FlareAssetRegistry: {
        name: "FlareAssetRegistry",
        interface: "IFlareAssetRegistry",
        registry: "FlareAssetRegistry",
        abi: interfaceAbis$1.IFlareAssetRegistry,
        getAddress: async (provider) => await nameToAddress$2("FlareAssetRegistry", provider),
    },
    FlareContractRegistry: {
        name: "FlareContractRegistry",
        interface: "IFlareContractRegistry",
        registry: "FlareContractRegistry",
        abi: interfaceAbis$1.IFlareContractRegistry,
        getAddress: async (provider) => await nameToAddress$2("FlareContractRegistry", provider),
    },
    FlareSystemsCalculator: {
        name: "FlareSystemsCalculator",
        interface: "IFlareSystemsCalculator",
        registry: "FlareSystemsCalculator",
        abi: interfaceAbis$1.IFlareSystemsCalculator,
        getAddress: async (provider) => await nameToAddress$2("FlareSystemsCalculator", provider),
    },
    FlareSystemsManager: {
        name: "FlareSystemsManager",
        interface: "IFlareSystemsManager",
        registry: "FlareSystemsManager",
        abi: interfaceAbis$1.IFlareSystemsManager,
        getAddress: async (provider) => await nameToAddress$2("FlareSystemsManager", provider),
    },
    FtsoFeedDecimals: {
        name: "FtsoFeedDecimals",
        interface: "IFtsoFeedDecimals",
        registry: "FtsoFeedDecimals",
        abi: interfaceAbis$1.IFtsoFeedDecimals,
        getAddress: async (provider) => await nameToAddress$2("FtsoFeedDecimals", provider),
    },
    FtsoFeedIdConverter: {
        name: "FtsoFeedIdConverter",
        interface: "IFtsoFeedIdConverter",
        registry: "FtsoFeedIdConverter",
        abi: interfaceAbis$1.IFtsoFeedIdConverter,
        getAddress: async (provider) => await nameToAddress$2("FtsoFeedIdConverter", provider),
    },
    FtsoFeedPublisher: {
        name: "FtsoFeedPublisher",
        interface: "IFtsoFeedPublisher",
        registry: "FtsoFeedPublisher",
        abi: interfaceAbis$1.IFtsoFeedPublisher,
        getAddress: async (provider) => await nameToAddress$2("FtsoFeedPublisher", provider),
    },
    FtsoInflationConfigurations: {
        name: "FtsoInflationConfigurations",
        interface: "IFtsoInflationConfigurations",
        registry: "FtsoInflationConfigurations",
        abi: interfaceAbis$1.IFtsoInflationConfigurations,
        getAddress: async (provider) => await nameToAddress$2("FtsoInflationConfigurations", provider),
    },
    FtsoManager: {
        name: "FtsoManager",
        interface: "IFtsoManager",
        registry: "FtsoManager",
        abi: interfaceAbis$1.IFtsoManager,
        getAddress: async (provider) => await nameToAddress$2("FtsoManager", provider),
    },
    FtsoRegistry: {
        name: "FtsoRegistry",
        interface: "IFtsoRegistry",
        registry: "FtsoRegistry",
        abi: interfaceAbis$1.IFtsoRegistry,
        getAddress: async (provider) => await nameToAddress$2("FtsoRegistry", provider),
    },
    FtsoRewardManager: {
        name: "FtsoRewardManager",
        interface: "IFtsoRewardManager",
        registry: "FtsoRewardManager",
        abi: interfaceAbis$1.IFtsoRewardManager,
        getAddress: async (provider) => await nameToAddress$2("FtsoRewardManager", provider),
    },
    FtsoRewardOffersManager: {
        name: "FtsoRewardOffersManager",
        interface: "IFtsoRewardOffersManager",
        registry: "FtsoRewardOffersManager",
        abi: interfaceAbis$1.IFtsoRewardOffersManager,
        getAddress: async (provider) => await nameToAddress$2("FtsoRewardOffersManager", provider),
    },
    FtsoV2: {
        name: "FtsoV2",
        interface: "FtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis$1.FtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$2("FtsoV2", provider),
    },
    GovernanceSettings: {
        name: "GovernanceSettings",
        interface: "IGovernanceSettings",
        registry: "GovernanceSettings",
        abi: interfaceAbis$1.IGovernanceSettings,
        getAddress: async (provider) => await nameToAddress$2("GovernanceSettings", provider),
    },
    GovernanceVotePower: {
        name: "GovernanceVotePower",
        interface: "IGovernanceVotePower",
        registry: "GovernanceVotePower",
        abi: interfaceAbis$1.IGovernanceVotePower,
        getAddress: async (provider) => await nameToAddress$2("GovernanceVotePower", provider),
    },
    PriceSubmitter: {
        name: "PriceSubmitter",
        interface: "IPriceSubmitter",
        registry: "PriceSubmitter",
        abi: interfaceAbis$1.IPriceSubmitter,
        getAddress: async (provider) => await nameToAddress$2("PriceSubmitter", provider),
    },
    ProtocolsV2: {
        name: "ProtocolsV2",
        interface: "ProtocolsV2Interface",
        registry: "ProtocolsV2",
        abi: interfaceAbis$1.ProtocolsV2Interface,
        getAddress: async (provider) => await nameToAddress$2("ProtocolsV2", provider),
    },
    RandomNumberV2: {
        name: "RandomNumberV2",
        interface: "RandomNumberV2Interface",
        registry: "RandomNumberV2",
        abi: interfaceAbis$1.RandomNumberV2Interface,
        getAddress: async (provider) => await nameToAddress$2("RandomNumberV2", provider),
    },
    Relay: {
        name: "Relay",
        interface: "IRelay",
        registry: "Relay",
        abi: interfaceAbis$1.IRelay,
        getAddress: async (provider) => await nameToAddress$2("Relay", provider),
    },
    RewardManager: {
        name: "RewardManager",
        interface: "IRewardManager",
        registry: "RewardManager",
        abi: interfaceAbis$1.IRewardManager,
        getAddress: async (provider) => await nameToAddress$2("RewardManager", provider),
    },
    RewardsV2: {
        name: "RewardsV2",
        interface: "RewardsV2Interface",
        registry: "RewardsV2",
        abi: interfaceAbis$1.RewardsV2Interface,
        getAddress: async (provider) => await nameToAddress$2("RewardsV2", provider),
    },
    Submission: {
        name: "Submission",
        interface: "ISubmission",
        registry: "Submission",
        abi: interfaceAbis$1.ISubmission,
        getAddress: async (provider) => await nameToAddress$2("Submission", provider),
    },
    TestFtsoV2: {
        name: "TestFtsoV2",
        interface: "TestFtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis$1.TestFtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$2("FtsoV2", provider),
    },
    ValidatorRewardManager: {
        name: "ValidatorRewardManager",
        interface: "IGenericRewardManager",
        registry: "ValidatorRewardManager",
        abi: interfaceAbis$1.IGenericRewardManager,
        getAddress: async (provider) => await nameToAddress$2("ValidatorRewardManager", provider),
    },
    VoterRegistry: {
        name: "VoterRegistry",
        interface: "IVoterRegistry",
        registry: "VoterRegistry",
        abi: interfaceAbis$1.IVoterRegistry,
        getAddress: async (provider) => await nameToAddress$2("VoterRegistry", provider),
    },
    VoterWhitelister: {
        name: "VoterWhitelister",
        interface: "IVoterWhitelister",
        registry: "VoterWhitelister",
        abi: interfaceAbis$1.IVoterWhitelister,
        getAddress: async (provider) => await nameToAddress$2("VoterWhitelister", provider),
    },
    WNat: {
        name: "WNat",
        interface: "IWNat",
        registry: "WNat",
        abi: interfaceAbis$1.IWNat,
        getAddress: async (provider) => await nameToAddress$2("WNat", provider),
    },
    WNatDelegationFee: {
        name: "WNatDelegationFee",
        interface: "IWNatDelegationFee",
        registry: "WNatDelegationFee",
        abi: interfaceAbis$1.IWNatDelegationFee,
        getAddress: async (provider) => await nameToAddress$2("WNatDelegationFee", provider),
    },
};

const nameToAbi$2 = (name) => {
    var _a;
    try {
        const abiData = (_a = products$1[name]) === null || _a === void 0 ? void 0 : _a.abi;
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network contract with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network contract with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network contract with name "${name}".`);
};
const interfaceToAbi$2 = (name) => {
    try {
        const abiData = interfaceAbis$1[name];
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network interface with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network interface with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network interface with name "${name}".`);
};

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    interfaceAbis: interfaceAbis$1,
    interfaceToAbi: interfaceToAbi$2,
    nameToAbi: nameToAbi$2,
    products: products$1
});

const nameToAddress$1 = async (name, provider) => {
    const fcrContract = new Contract(FlareContractRegistryAddress, interfaceAbis.IFlareContractRegistry, provider);
    return await fcrContract.getContractAddressByName(name);
};
const interfaceAbis = {
    AgentInfo: AgentInfo$3,
    AgentSettings: AgentSettings$3,
    AssetManagerSettings: AssetManagerSettings$3,
    AvailableAgentInfo: AvailableAgentInfo$3,
    CollateralReservationInfo: CollateralReservationInfo$3,
    CollateralType: CollateralType$3,
    ContractRegistry: ContractRegistry$3,
    FtsoV2Interface: FtsoV2Interface$3,
    IAddressValidity: IAddressValidity$3,
    IAddressValidityVerification: IAddressValidityVerification$3,
    IAgentAlwaysAllowedMinters: IAgentAlwaysAllowedMinters$3,
    IAgentOwnerRegistry: IAgentOwnerRegistry$3,
    IAgentPing: IAgentPing$3,
    IAssetManager: IAssetManager$3,
    IAssetManagerController: IAssetManagerController$3,
    IAssetManagerEvents: IAssetManagerEvents$3,
    IBalanceDecreasingTransaction: IBalanceDecreasingTransaction$3,
    IBalanceDecreasingTransactionVerification: IBalanceDecreasingTransactionVerification$3,
    ICChainStake: ICChainStake$3,
    ICChainVotePower: ICChainVotePower$3,
    IClaimSetupManager: IClaimSetupManager$3,
    ICollateralizable: ICollateralizable,
    IConfirmedBlockHeightExists: IConfirmedBlockHeightExists$3,
    IConfirmedBlockHeightExistsVerification: IConfirmedBlockHeightExistsVerification$3,
    ICoreVault: ICoreVault$1,
    ICoreVaultSettings: ICoreVaultSettings$1,
    IDelegationAccount: IDelegationAccount$3,
    IDiamondLoupe: IDiamondLoupe$3,
    IEVMTransaction: IEVMTransaction$3,
    IEVMTransactionVerification: IEVMTransactionVerification$3,
    IEntityManager: IEntityManager$3,
    IFastUpdateIncentiveManager: IFastUpdateIncentiveManager$3,
    IFastUpdater: IFastUpdater$3,
    IFastUpdatesConfiguration: IFastUpdatesConfiguration$3,
    IFdcHub: IFdcHub$3,
    IFdcInflationConfigurations: IFdcInflationConfigurations$3,
    IFdcRequestFeeConfigurations: IFdcRequestFeeConfigurations$3,
    IFdcVerification: IFdcVerification$3,
    IFeeCalculator: IFeeCalculator$3,
    IFlareAssetRegistry: IFlareAssetRegistry$3,
    IFlareContractRegistry: IFlareContractRegistry$3,
    IFlareDaemonize: IFlareDaemonize$3,
    IFlareSystemsCalculator: IFlareSystemsCalculator$3,
    IFlareSystemsManager: IFlareSystemsManager$3,
    IFtso: IFtso$3,
    IFtsoFeedDecimals: IFtsoFeedDecimals$3,
    IFtsoFeedIdConverter: IFtsoFeedIdConverter$3,
    IFtsoFeedPublisher: IFtsoFeedPublisher$3,
    IFtsoGenesis: IFtsoGenesis$3,
    IFtsoInflationConfigurations: IFtsoInflationConfigurations$3,
    IFtsoManager: IFtsoManager$3,
    IFtsoManagerGenesis: IFtsoManagerGenesis$3,
    IFtsoRegistry: IFtsoRegistry$3,
    IFtsoRegistryGenesis: IFtsoRegistryGenesis$3,
    IFtsoRewardManager: IFtsoRewardManager$3,
    IFtsoRewardOffersManager: IFtsoRewardOffersManager$3,
    IGenericRewardManager: IGenericRewardManager$3,
    IGovernanceSettings: IGovernanceSettings$3,
    IGovernanceVotePower: IGovernanceVotePower$3,
    IGovernor: IGovernor$3,
    IIAddressUpdatable: IIAddressUpdatable$3,
    IIAddressUpdater: IIAddressUpdater$3,
    IIClaimSetupManager: IIClaimSetupManager$3,
    IICleanable: IICleanable$3,
    IICleanupBlockNumberManager: IICleanupBlockNumberManager$3,
    IICustomFeed: IICustomFeed$3,
    IIERC20WithMetadata: IIERC20WithMetadata,
    IIEntityManager: IIEntityManager$3,
    IIFastUpdaterView: IIFastUpdaterView$3,
    IIFlareAssetRegistry: IIFlareAssetRegistry,
    IIFlareAssetRegistryProvider: IIFlareAssetRegistryProvider,
    IIFlareSystemsCalculator: IIFlareSystemsCalculator$3,
    IIFlareSystemsManager: IIFlareSystemsManager$3,
    IIFtso: IIFtso$3,
    IIFtsoFeedPublisher: IIFtsoFeedPublisher$3,
    IIFtsoManager: IIFtsoManager,
    IIFtsoManagerProxy: IIFtsoManagerProxy$3,
    IIFtsoManagerV1: IIFtsoManagerV1,
    IIFtsoRegistry: IIFtsoRegistry,
    IIFtsoRegistryV1: IIFtsoRegistryV1,
    IIFtsoRewardManager: IIFtsoRewardManager,
    IIGovernanceVotePower: IIGovernanceVotePower$3,
    IIGovernorProposer: IIGovernorProposer$3,
    IIInflationAllocation: IIInflationAllocation,
    IIInflationReceiver: IIInflationReceiver,
    IIInflationReceiverV1: IIInflationReceiverV1,
    IIInflationV1: IIInflationV1,
    IINodePossessionVerifier: IINodePossessionVerifier$3,
    IIPollingFoundation: IIPollingFoundation$3,
    IIPollingManagementGroup: IIPollingManagementGroup$3,
    IIPreInflationCalculation: IIPreInflationCalculation,
    IIPriceSubmitter: IIPriceSubmitter,
    IIPublicKeyVerifier: IIPublicKeyVerifier$3,
    IIRNat: IIRNat$3,
    IIRNatAccount: IIRNatAccount$3,
    IIRandomProvider: IIRandomProvider,
    IIRelay: IIRelay$3,
    IIRewardEpochSwitchoverTrigger: IIRewardEpochSwitchoverTrigger$3,
    IIRewardManager: IIRewardManager$3,
    IISubmission: IISubmission$3,
    IISupply: IISupply,
    IITokenPool: IITokenPool,
    IIVPContract: IIVPContract$3,
    IIVPToken: IIVPToken$3,
    IIVoterRegistrationTrigger: IIVoterRegistrationTrigger$3,
    IIVoterRegistry: IIVoterRegistry$3,
    IIVoterWhitelister: IIVoterWhitelister,
    IIncreaseManager: IIncreaseManager$3,
    IInflationGenesis: IInflationGenesis,
    IJsonApi: IJsonApi$3,
    IJsonApiVerification: IJsonApiVerification$3,
    IPayment: IPayment$3,
    IPaymentVerification: IPaymentVerification$3,
    IPollingFtso: IPollingFtso$2,
    IPollingManagementGroup: IPollingManagementGroup$3,
    IPriceSubmitter: IPriceSubmitter$3,
    IRNat: IRNat$3,
    IRNatAccount: IRNatAccount$3,
    IRandomProvider: IRandomProvider$3,
    IRedemptionTimeExtension: IRedemptionTimeExtension$3,
    IReferencedPaymentNonexistence: IReferencedPaymentNonexistence$3,
    IReferencedPaymentNonexistenceVerification: IReferencedPaymentNonexistenceVerification$3,
    IRelay: IRelay$3,
    IRewardManager: IRewardManager$3,
    ISubmission: ISubmission$3,
    ITransferFees: ITransferFees$1,
    ITypeTemplate: ITypeTemplate$3,
    ITypeTemplateVerification: ITypeTemplateVerification$3,
    IUpdateValidators: IUpdateValidators,
    IVPContractEvents: IVPContractEvents$3,
    IVPToken: IVPToken$3,
    IValidatorRewardOffersManager: IValidatorRewardOffersManager$3,
    IVoterPreRegistry: IVoterPreRegistry$3,
    IVoterRegistry: IVoterRegistry$3,
    IVoterWhitelister: IVoterWhitelister$3,
    IWNat: IWNat$3,
    IWNatDelegationFee: IWNatDelegationFee$3,
    IWeb2Json: IWeb2Json$3,
    IWeb2JsonVerification: IWeb2JsonVerification$3,
    IWhitelist: IWhitelist$1,
    ProtocolsV2Interface: ProtocolsV2Interface$3,
    RandomNumberV2Interface: RandomNumberV2Interface$3,
    RedemptionRequestInfo: RedemptionRequestInfo$3,
    RedemptionTicketInfo: RedemptionTicketInfo$3,
    RewardsV2Interface: RewardsV2Interface$3,
    TestFtsoV2Interface: TestFtsoV2Interface$3,
};
const products = {
    AssetManagerController: {
        name: "AssetManagerController",
        interface: "IAssetManagerController",
        registry: "AssetManagerController",
        abi: interfaceAbis.IAssetManagerController,
        getAddress: async (provider) => await nameToAddress$1("AssetManagerController", provider),
    },
    AssetManagerFXRP: {
        name: "AssetManagerFXRP",
        interface: "IAssetManager",
        registry: "AssetManagerFXRP",
        abi: interfaceAbis.IAssetManager,
        getAddress: async (provider) => await nameToAddress$1("AssetManagerFXRP", provider),
    },
    ClaimSetupManager: {
        name: "ClaimSetupManager",
        interface: "IClaimSetupManager",
        registry: "ClaimSetupManager",
        abi: interfaceAbis.IClaimSetupManager,
        getAddress: async (provider) => await nameToAddress$1("ClaimSetupManager", provider),
    },
    EntityManager: {
        name: "EntityManager",
        interface: "IEntityManager",
        registry: "EntityManager",
        abi: interfaceAbis.IEntityManager,
        getAddress: async (provider) => await nameToAddress$1("EntityManager", provider),
    },
    FastUpdateIncentiveManager: {
        name: "FastUpdateIncentiveManager",
        interface: "IFastUpdateIncentiveManager",
        registry: "FastUpdateIncentiveManager",
        abi: interfaceAbis.IFastUpdateIncentiveManager,
        getAddress: async (provider) => await nameToAddress$1("FastUpdateIncentiveManager", provider),
    },
    FastUpdater: {
        name: "FastUpdater",
        interface: "IFastUpdater",
        registry: "FastUpdater",
        abi: interfaceAbis.IFastUpdater,
        getAddress: async (provider) => await nameToAddress$1("FastUpdater", provider),
    },
    FastUpdatesConfiguration: {
        name: "FastUpdatesConfiguration",
        interface: "IFastUpdatesConfiguration",
        registry: "FastUpdatesConfiguration",
        abi: interfaceAbis.IFastUpdatesConfiguration,
        getAddress: async (provider) => await nameToAddress$1("FastUpdatesConfiguration", provider),
    },
    FdcHub: {
        name: "FdcHub",
        interface: "IFdcHub",
        registry: "FdcHub",
        abi: interfaceAbis.IFdcHub,
        getAddress: async (provider) => await nameToAddress$1("FdcHub", provider),
    },
    FdcRequestFeeConfigurations: {
        name: "FdcRequestFeeConfigurations",
        interface: "IFdcRequestFeeConfigurations",
        registry: "FdcRequestFeeConfigurations",
        abi: interfaceAbis.IFdcRequestFeeConfigurations,
        getAddress: async (provider) => await nameToAddress$1("FdcRequestFeeConfigurations", provider),
    },
    FdcVerification: {
        name: "FdcVerification",
        interface: "IFdcVerification",
        registry: "FdcVerification",
        abi: interfaceAbis.IFdcVerification,
        getAddress: async (provider) => await nameToAddress$1("FdcVerification", provider),
    },
    FeeCalculator: {
        name: "FeeCalculator",
        interface: "IFeeCalculator",
        registry: "FeeCalculator",
        abi: interfaceAbis.IFeeCalculator,
        getAddress: async (provider) => await nameToAddress$1("FeeCalculator", provider),
    },
    FlareAssetRegistry: {
        name: "FlareAssetRegistry",
        interface: "IFlareAssetRegistry",
        registry: "FlareAssetRegistry",
        abi: interfaceAbis.IFlareAssetRegistry,
        getAddress: async (provider) => await nameToAddress$1("FlareAssetRegistry", provider),
    },
    FlareContractRegistry: {
        name: "FlareContractRegistry",
        interface: "IFlareContractRegistry",
        registry: "FlareContractRegistry",
        abi: interfaceAbis.IFlareContractRegistry,
        getAddress: async (provider) => await nameToAddress$1("FlareContractRegistry", provider),
    },
    FlareSystemsCalculator: {
        name: "FlareSystemsCalculator",
        interface: "IFlareSystemsCalculator",
        registry: "FlareSystemsCalculator",
        abi: interfaceAbis.IFlareSystemsCalculator,
        getAddress: async (provider) => await nameToAddress$1("FlareSystemsCalculator", provider),
    },
    FlareSystemsManager: {
        name: "FlareSystemsManager",
        interface: "IFlareSystemsManager",
        registry: "FlareSystemsManager",
        abi: interfaceAbis.IFlareSystemsManager,
        getAddress: async (provider) => await nameToAddress$1("FlareSystemsManager", provider),
    },
    FtsoFeedDecimals: {
        name: "FtsoFeedDecimals",
        interface: "IFtsoFeedDecimals",
        registry: "FtsoFeedDecimals",
        abi: interfaceAbis.IFtsoFeedDecimals,
        getAddress: async (provider) => await nameToAddress$1("FtsoFeedDecimals", provider),
    },
    FtsoFeedIdConverter: {
        name: "FtsoFeedIdConverter",
        interface: "IFtsoFeedIdConverter",
        registry: "FtsoFeedIdConverter",
        abi: interfaceAbis.IFtsoFeedIdConverter,
        getAddress: async (provider) => await nameToAddress$1("FtsoFeedIdConverter", provider),
    },
    FtsoFeedPublisher: {
        name: "FtsoFeedPublisher",
        interface: "IFtsoFeedPublisher",
        registry: "FtsoFeedPublisher",
        abi: interfaceAbis.IFtsoFeedPublisher,
        getAddress: async (provider) => await nameToAddress$1("FtsoFeedPublisher", provider),
    },
    FtsoInflationConfigurations: {
        name: "FtsoInflationConfigurations",
        interface: "IFtsoInflationConfigurations",
        registry: "FtsoInflationConfigurations",
        abi: interfaceAbis.IFtsoInflationConfigurations,
        getAddress: async (provider) => await nameToAddress$1("FtsoInflationConfigurations", provider),
    },
    FtsoManager: {
        name: "FtsoManager",
        interface: "IFtsoManager",
        registry: "FtsoManager",
        abi: interfaceAbis.IFtsoManager,
        getAddress: async (provider) => await nameToAddress$1("FtsoManager", provider),
    },
    FtsoRegistry: {
        name: "FtsoRegistry",
        interface: "IFtsoRegistry",
        registry: "FtsoRegistry",
        abi: interfaceAbis.IFtsoRegistry,
        getAddress: async (provider) => await nameToAddress$1("FtsoRegistry", provider),
    },
    FtsoRewardManager: {
        name: "FtsoRewardManager",
        interface: "IFtsoRewardManager",
        registry: "FtsoRewardManager",
        abi: interfaceAbis.IFtsoRewardManager,
        getAddress: async (provider) => await nameToAddress$1("FtsoRewardManager", provider),
    },
    FtsoRewardOffersManager: {
        name: "FtsoRewardOffersManager",
        interface: "IFtsoRewardOffersManager",
        registry: "FtsoRewardOffersManager",
        abi: interfaceAbis.IFtsoRewardOffersManager,
        getAddress: async (provider) => await nameToAddress$1("FtsoRewardOffersManager", provider),
    },
    FtsoV2: {
        name: "FtsoV2",
        interface: "FtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis.FtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$1("FtsoV2", provider),
    },
    GovernanceSettings: {
        name: "GovernanceSettings",
        interface: "IGovernanceSettings",
        registry: "GovernanceSettings",
        abi: interfaceAbis.IGovernanceSettings,
        getAddress: async (provider) => await nameToAddress$1("GovernanceSettings", provider),
    },
    GovernanceVotePower: {
        name: "GovernanceVotePower",
        interface: "IGovernanceVotePower",
        registry: "GovernanceVotePower",
        abi: interfaceAbis.IGovernanceVotePower,
        getAddress: async (provider) => await nameToAddress$1("GovernanceVotePower", provider),
    },
    PriceSubmitter: {
        name: "PriceSubmitter",
        interface: "IPriceSubmitter",
        registry: "PriceSubmitter",
        abi: interfaceAbis.IPriceSubmitter,
        getAddress: async (provider) => await nameToAddress$1("PriceSubmitter", provider),
    },
    ProtocolsV2: {
        name: "ProtocolsV2",
        interface: "ProtocolsV2Interface",
        registry: "ProtocolsV2",
        abi: interfaceAbis.ProtocolsV2Interface,
        getAddress: async (provider) => await nameToAddress$1("ProtocolsV2", provider),
    },
    RandomNumberV2: {
        name: "RandomNumberV2",
        interface: "RandomNumberV2Interface",
        registry: "RandomNumberV2",
        abi: interfaceAbis.RandomNumberV2Interface,
        getAddress: async (provider) => await nameToAddress$1("RandomNumberV2", provider),
    },
    Relay: {
        name: "Relay",
        interface: "IRelay",
        registry: "Relay",
        abi: interfaceAbis.IRelay,
        getAddress: async (provider) => await nameToAddress$1("Relay", provider),
    },
    RewardManager: {
        name: "RewardManager",
        interface: "IRewardManager",
        registry: "RewardManager",
        abi: interfaceAbis.IRewardManager,
        getAddress: async (provider) => await nameToAddress$1("RewardManager", provider),
    },
    RewardsV2: {
        name: "RewardsV2",
        interface: "RewardsV2Interface",
        registry: "RewardsV2",
        abi: interfaceAbis.RewardsV2Interface,
        getAddress: async (provider) => await nameToAddress$1("RewardsV2", provider),
    },
    Submission: {
        name: "Submission",
        interface: "ISubmission",
        registry: "Submission",
        abi: interfaceAbis.ISubmission,
        getAddress: async (provider) => await nameToAddress$1("Submission", provider),
    },
    TestFtsoV2: {
        name: "TestFtsoV2",
        interface: "TestFtsoV2Interface",
        registry: "FtsoV2",
        abi: interfaceAbis.TestFtsoV2Interface,
        getAddress: async (provider) => await nameToAddress$1("FtsoV2", provider),
    },
    VoterRegistry: {
        name: "VoterRegistry",
        interface: "IVoterRegistry",
        registry: "VoterRegistry",
        abi: interfaceAbis.IVoterRegistry,
        getAddress: async (provider) => await nameToAddress$1("VoterRegistry", provider),
    },
    VoterWhitelister: {
        name: "VoterWhitelister",
        interface: "IVoterWhitelister",
        registry: "VoterWhitelister",
        abi: interfaceAbis.IVoterWhitelister,
        getAddress: async (provider) => await nameToAddress$1("VoterWhitelister", provider),
    },
    WNat: {
        name: "WNat",
        interface: "IWNat",
        registry: "WNat",
        abi: interfaceAbis.IWNat,
        getAddress: async (provider) => await nameToAddress$1("WNat", provider),
    },
    WNatDelegationFee: {
        name: "WNatDelegationFee",
        interface: "IWNatDelegationFee",
        registry: "WNatDelegationFee",
        abi: interfaceAbis.IWNatDelegationFee,
        getAddress: async (provider) => await nameToAddress$1("WNatDelegationFee", provider),
    },
};

const nameToAbi$1 = (name) => {
    var _a;
    try {
        const abiData = (_a = products[name]) === null || _a === void 0 ? void 0 : _a.abi;
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network contract with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network contract with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network contract with name "${name}".`);
};
const interfaceToAbi$1 = (name) => {
    try {
        const abiData = interfaceAbis[name];
        if (abiData !== undefined)
            return abiData;
        throw new TypeError(`No official Flare Network interface with name "${name}".`);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new TypeError(`No official Flare Network interface with name "${name}".`);
        }
    }
    throw new Error(`Unknown exception occured. Could not find any official Flare Network interface with name "${name}".`);
};

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    interfaceAbis: interfaceAbis,
    interfaceToAbi: interfaceToAbi$1,
    nameToAbi: nameToAbi$1,
    products: products
});

// This should never change
const FlareContractRegistryAddress = "0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019";
const nameToAddress = async (name, network, provider) => {
    const fcrContract = new Contract(FlareContractRegistryAddress, nameToAbi("FlareContractRegistry", network), provider);
    return await fcrContract.getContractAddressByName(name);
};
const namesToAddresses = async (names, network, provider) => {
    const fcrContract = new Contract(FlareContractRegistryAddress, nameToAbi("FlareContractRegistry", network), provider);
    return await fcrContract.getContractAddressesByName(names);
};
const nameToAbi = (name, network) => {
    switch (network.toLocaleLowerCase()) {
        case "flare":
            return nameToAbi$2(name);
        case "songbird":
            return nameToAbi$1(name);
        case "coston":
            return nameToAbi$4(name);
        case "coston2":
            return nameToAbi$3(name);
    }
    throw new TypeError(`Unsupported network "${network}". Supported networks are flare, coston2, songbird and coston.`);
};
const interfaceToAbi = (name, network) => {
    switch (network.toLocaleLowerCase()) {
        case "flare":
            return interfaceToAbi$2(name);
        case "songbird":
            return interfaceToAbi$1(name);
        case "coston":
            return interfaceToAbi$4(name);
        case "coston2":
            return interfaceToAbi$3(name);
    }
    throw new TypeError(`Unsupported network "${network}". Supported networks are flare, coston2, songbird and coston.`);
};

exports.FlareContractRegistryAddress = FlareContractRegistryAddress;
exports.coston = index$3;
exports.coston2 = index$2;
exports.flare = index$1;
exports.interfaceToAbi = interfaceToAbi;
exports.nameToAbi = nameToAbi;
exports.nameToAddress = nameToAddress;
exports.namesToAddresses = namesToAddresses;
exports.songbird = index;
//# sourceMappingURL=index.js.map
